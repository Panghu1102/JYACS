# 对话卡死问题修复任务列表（更新版）

## 阶段 1: 最小侵入性修复（P0 - 立即执行）

### 任务组 1：改进状态同步和验证


- [ ] 1. 在内层循环结束后添加状态重置和验证代码
  - 在 `jyacs_main.rpy` 约第 360 行（内层循环结束后，触发器处理之后）添加代码
  - 记录重置前的状态（is_responding, is_chatting, is_ready_to_input, message_queue length）
  - 明确重置 is_responding 和 is_chatting 为 False
  - 清空消息队列中的残留消息（如果有）
  - 添加 0.3 秒延迟（renpy.pause(0.3, hard=True)）
  - 记录重置后的状态
  - 进行状态一致性检查，如果仍有异常则再次重置
  - 添加详细的 DEBUG 级别日志
  - _Requirements: 需求 2.1, 2.2, 2.3, 2.4, 2.5, 需求 3.1, 3.2, 3.5_

- [ ] 2. 在调用 renpy.input() 前添加状态验证和自动修复
  - 在 `jyacs_main.rpy` 约第 220 行（外层循环开头，调用 renpy.input() 之前）添加代码
  - 实现状态验证循环（最多尝试 3 次）
  - 检查 is_responding 应为 False
  - 检查 is_chatting 应为 False
  - 检查 message_queue 应为空
  - 如果验证失败，尝试修复状态并等待 0.2 秒
  - 如果连续 3 次验证失败，记录错误并强制退出对话循环
  - 添加详细的 DEBUG 和 WARNING 级别日志
  - _Requirements: 需求 4.1, 4.2, 4.3, 4.4, 需求 3.1, 3.2, 3.4_

- [ ]* 2.1 测试状态同步修复
  - 启动游戏并进入对话
  - 进行至少 10 轮完整对话
  - 验证不会在 AI 响应后卡死
  - 检查日志文件，确认状态在每轮之间正确重置
  - 验证没有状态验证失败的警告
  - _Requirements: 需求 2.1, 2.2, 2.4, 需求 4.1, 4.2_

### 任务组 2：改进日志记录

- [ ] 3. 在外层循环开头添加详细的状态日志
  - 在 `jyacs_main.rpy` 外层循环开头（约第 200 行）添加日志
  - 记录循环计数（outer_loop_count）
  - 记录时间戳（time.time()）
  - 记录所有关键状态标志的值
  - 使用分隔线（"="*60）使日志更易读
  - _Requirements: 需求 3.1, 3.2_

- [ ] 4. 在关键操作前后添加日志
  - 在调用 renpy.input() 前后添加日志（记录时间戳）
  - 在调用 y() 显示对话前后添加日志（记录时间戳和消息内容前 50 字符）
  - 在内层循环退出时添加日志（记录退出原因和最终状态）
  - 在触发器处理前后添加日志
  - _Requirements: 需求 3.3, 3.4, 3.5_

- [ ]* 4.1 验证日志记录
  - 进行 3 轮对话
  - 查看日志文件（JYACS console.txt）
  - 验证日志清晰显示每轮对话的完整流程
  - 验证可以看到状态的变化
  - 验证可以看到每个关键操作的时间戳
  - 验证日志格式易于阅读和分析
  - _Requirements: 需求 3.1, 3.2, 3.3, 3.4, 3.5, 需求 3.6_

### 任务组 3：添加防护机制

- [ ] 5. 为外层循环添加最大迭代次数检查
  - 验证 `max_outer_loops = 100` 已定义
  - 验证在每次循环开始时检查 `outer_loop_count`
  - 如果达到最大值，记录 ERROR 日志并退出
  - _Requirements: 需求 5.3_

- [ ] 6. 为内层循环添加超时和迭代次数检查
  - 在内层循环开始时记录 `start_time = time.time()`
  - 定义 `timeout = 60` 秒和 `max_inner_loops = 50`
  - 在每次循环迭代时检查是否超时或达到最大迭代次数
  - 如果超时或达到最大值，记录 WARNING/ERROR 日志并退出内层循环
  - _Requirements: 需求 5.1, 需求 5.2, 需求 5.3_

- [ ]* 6.1 测试防护机制
  - 模拟长时间等待（如网络慢）
  - 验证超时机制正常触发
  - 验证达到最大迭代次数时正常退出
  - 验证所有防护机制都有相应的日志记录
  - _Requirements: 需求 5.1, 5.2, 5.3_

### 任务组 4：改进错误处理

- [ ] 7. 为对话循环添加外层异常处理
  - 在 `python:` 块内添加 try-except 包装整个对话循环
  - 捕获所有异常类型
  - 记录完整的异常信息和堆栈跟踪
  - 设置 `dialogue_error` 变量保存错误信息
  - _Requirements: 需求 6.1, 需求 6.3_

- [ ] 8. 添加 finally 块进行清理
  - 在 try-except 后添加 finally 块
  - 重置所有状态标志（is_responding, is_chatting）
  - 清空消息队列
  - 记录清理完成日志
  - 即使发生异常也确保清理执行
  - _Requirements: 需求 6.2, 需求 6.3_

- [ ] 9. 在对话结束后显示错误信息（如果有）
  - 在 `label submod_jyacs_talking.end` 之前检查 `dialogue_error` 变量
  - 如果有错误，使用 Yuri 的对话显示友好的错误提示
  - 不暴露技术细节，只显示用户友好的信息
  - _Requirements: 需求 6.4_

- [ ]* 9.1 测试错误处理
  - 模拟各种异常情况（断网、API 错误等）
  - 验证系统能够优雅地处理异常
  - 验证用户能看到友好的错误提示
  - 验证系统能够从错误中恢复
  - 验证清理代码正常执行
  - _Requirements: 需求 6.1, 6.2, 6.3, 6.4, 需求 6.5_

## 阶段 2: 完整测试和验证（P0 - 紧急）

- [ ] 10. 执行完整的功能测试
  - [ ] 10.1 基本对话流程测试
    - 启动对话
    - 连续进行 10 轮对话
    - 每轮输入不同的消息
    - 验证每轮都能正常继续，不会卡死
    - 使用 "nevermind" 正常退出
    - _Requirements: 所有需求_
  
  - [ ] 10.2 快速点击测试
    - 启动对话
    - 在 AI 响应显示时快速连续点击屏幕
    - 验证不会出现状态混乱
    - 验证对话能够正常继续
    - _Requirements: 需求 2.x, 需求 4.x_
  
  - [ ] 10.3 网络异常测试
    - 启动对话
    - 在对话过程中断开网络
    - 验证系统能够检测到断开
    - 验证显示友好的错误提示
    - 恢复网络后验证能够重连
    - _Requirements: 需求 6.x_

- [ ] 11. 日志分析和验证
  - [ ] 11.1 查看日志文件
    - 进行 3-5 轮对话
    - 打开 `JYACS console.txt` 日志文件
    - 验证日志清晰显示每轮对话的流程
    - 验证可以看到状态的变化
    - 验证可以看到每个关键操作的时间戳
    - _Requirements: 需求 3.x_
  
  - [ ] 11.2 分析状态重置日志
    - 查找 "一轮对话完成，开始状态重置" 日志
    - 验证每轮对话后都有状态重置
    - 验证重置前后的状态记录完整
    - 验证没有状态验证失败的警告
    - _Requirements: 需求 2.x, 需求 4.x_
  
  - [ ] 11.3 检查异常和警告
    - 查找所有 WARNING 和 ERROR 级别的日志
    - 分析是否有未预期的警告或错误
    - 如果有，分析原因并决定是否需要进一步修复
    - _Requirements: 所有需求_

- [ ] 12. 性能和用户体验验证
  - [ ] 12.1 测量响应延迟
    - 记录每轮对话之间的延迟时间
    - 验证延迟在可接受范围内（< 0.5 秒）
    - 验证用户不会明显感知到延迟
    - _Requirements: 需求 2.4_
  
  - [ ] 12.2 长时间对话测试
    - 进行 20-30 轮对话
    - 验证系统稳定性
    - 验证内存使用正常
    - 验证没有性能下降
    - _Requirements: 所有需求_

## 阶段 3: 文档和总结（P1 - 高优先级）

- [ ] 13. 更新文档
  - [ ] 13.1 创建修复总结文档
    - 记录所有修改的文件和位置
    - 记录修改的内容和原因
    - 记录测试结果
    - 记录已知问题和限制
    - _Requirements: 所有需求_
  
  - [ ] 13.2 更新用户文档
    - 说明对话功能的正确使用方法
    - 添加常见问题和解决方法
    - 添加故障排除指南
    - _Requirements: 所有需求_
  
  - [ ] 13.3 创建开发者文档
    - 说明对话循环的实现细节
    - 说明状态管理机制
    - 说明异常处理策略
    - 添加代码注释
    - _Requirements: 所有需求_

## 阶段 4: 备份和回滚准备（P2 - 中优先级）

- [ ] 14. 创建备份和回滚机制
  - [ ] 14.1 备份原始文件
    - 创建 `.kiro/backup/` 目录
    - 备份修改前的 `jyacs_main.rpy`
    - 记录备份时间和版本
    - _Requirements: 所有需求_
  
  - [ ] 14.2 创建回滚脚本
    - 创建 PowerShell 回滚脚本
    - 测试回滚脚本是否正常工作
    - 记录回滚步骤
    - _Requirements: 所有需求_

## 验收标准

完成以上所有任务后，系统应满足以下标准：

### 功能性标准
1. AI 返回内容后，点击屏幕能够正常继续对话，不会卡死
2. 连续进行 10 轮对话不出现卡死或异常
3. 每轮对话之间状态标志正确重置和同步

### 稳定性标准
1. 即使发生异常，也能优雅地提示用户并退出
2. 等待超时时能够正确处理，不会无限等待
3. 消息队列不会无限增长，内存使用正常

### 性能标准
1. 修复后的代码不应显著影响对话响应速度（延迟 < 0.5 秒）
2. 用户不应感知到状态重置和验证的延迟

### 可诊断性标准
1. 如果再次出现问题，日志应该能够清楚地显示卡在哪里
2. 日志应该记录所有关键状态的变化
3. 异常应该有完整的堆栈跟踪

## 注意事项

1. **增量实施**: 按任务组顺序实施，每个任务组完成后进行测试
2. **代码备份**: 在修改前备份 `jyacs_main.rpy` 文件
3. **测试优先**: 每个任务组完成后立即测试，不要累积问题
4. **日志分析**: 仔细分析日志，确认修复是否有效
5. **用户体验**: 确保错误提示友好，不要暴露技术细节

## 如果阶段 1 无效

如果完成阶段 1 的所有任务后，问题仍然存在：

1. **分析日志**：仔细查看日志，确定卡死发生在哪里
2. **调整参数**：尝试增加延迟时间（如从 0.3 秒增加到 0.5 秒）
3. **考虑阶段 3**：如果仍然无效，需要实施设计文档中的阶段 3（拆分 Python 块），这需要大量重构

## 预期时间

- **任务组 1-2**：2-3 小时（编码）
- **任务组 3-4**：1-2 小时（编码）
- **阶段 2**：2-3 小时（测试）
- **阶段 3-4**：1-2 小时（文档和备份）
- **总计**：6-10 小时

## 风险评估

- **低风险**：任务组 1-2（状态同步和日志）
- **中风险**：任务组 3-4（防护和错误处理）
- **高风险**：如果需要实施阶段 3（拆分 Python 块）
