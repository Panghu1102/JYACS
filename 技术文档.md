# 欢迎！这里是JYACS的技术文档  
此文档会对JYACS的每一个文件进行深度解析，以帮助开发者更好了解这个项目，如果你只是普通的玩家，可以跳过这个文件（很枯燥的啦），那么我们直接开始。  
特别声明：为了节省不必要的人力，技术文档的部分内容会由ai进行总结，我会再检查一遍其叙述是否有问题，但无法保证一切都正确，麻烦谅解，另外，废弃的文件也不会总结。  
api.rpy：6  dev.rpy:546  header.rpy:1128(此文档内容过多，可能有些部分没有总结完)  emotions：1706  framework：2092  init：2508  main：2953  stub：3534  uihooks：

## jyacs_api.rpy 技术文档

许可证: Apache License 2.0
用途: JYACS (Just Yuri AI Chat Submod) 的 API 核心模块，负责与 AI API 通信、配置管理、对话历史管理和消息处理。

目录
初始化层级
核心类：JyacsAi
配置系统
对话历史管理
API 通信
辅助函数
标签（Labels）
数据流
初始化层级
init -1500: 基础配置
init -1500 python:
    # 语言配置
    if not hasattr(config, "language"):
        config.language = "english"
    
    # 版本信息
    jyacs_ver = '1.0.1'
    
    # 系统状态变量
    persistent.jyacs_stat = None
    persistent.jyacs_trigger_status = None
    persistent._jyacs_send_or_received_messages = []
功能：

设置默认语言配置
定义版本号
初始化持久化状态变量
init -1400: JyacsAi 类定义
这是整个文件的核心部分，定义了 AI 聊天的主要逻辑。

核心类：JyacsAi
类结构
class JyacsAi:
    """JYACS AI 聊天核心类"""
    
    def __init__(self):
        # API 配置
        self.api_key = ""
        self.api_url = ""
        self.model_name = "jyacs_main"
        
        # 状态管理
        self.status = "disconnected"
        self.is_connecting = False
        self.is_connected = False
        self.is_chatting = False
        self.is_responding = False
        self.is_failed = False
        
        # 消息队列
        self.message_queue = []
        
        # 对话历史
        self.conversation_history = []
        self.max_history_length = 20  # 最多保留 20 轮对话
        
        # 配置加载
        self._config_loaded = False
        self._load_config()
属性说明
| 属性 | 类型 | 说明 | |------|------|------| | api_key | str | API 密钥 | | api_url | str | API 端点地址 | | model_name | str | 使用的模型名称 | | status | str | 连接状态 | | is_connected | bool | 是否已连接 | | is_chatting | bool | 是否正在聊天 | | is_responding | bool | 是否正在等待响应 | | message_queue | list | 待处理的消息队列 | | conversation_history | list | 对话历史记录 | | system_prompt | str | 系统提示词 | | user_prompt_template | str | 用户消息模板 | | temperature | float | 模型温度参数 (0.7) | | top_p | float | 核采样参数 (0.9) | | max_tokens | int | 最大生成 token 数 (2048) |

配置系统
_load_config() 方法
功能：从 python-packages/jyacs_config.json 加载配置文件。

加载流程：

1. 尝试主路径: game/python-packages/jyacs_config.json
   ↓
2. 如果不存在，尝试备用路径:
   - basedir/game/python-packages/jyacs_config.json
   - basedir/python-packages/jyacs_config.json
   ↓
3. 解析 JSON 文件
   ↓
4. 加载配置项:
   - prompts.system_prompt (系统提示词)
   - prompts.user_prompt_template (用户消息模板)
   - api_config.temperature (温度)
   - api_config.top_p (核采样)
   - api_config.max_tokens (最大 token)
   ↓
5. 如果失败，使用默认配置
默认配置：

DEFAULT_SYSTEM_PROMPT = """
Role: Yuri (《Doki Doki Literature Club》中的角色)
Profile:
  author: Panghu1102
  version: 1.0
  language: 中文
  description: 你将扮演 Yuri——一个内向、敏感、热爱文学且常常自我矛盾的文学社成员...
"""

DEFAULT_USER_PROMPT_TEMPLATE = """
[player]说：{message}

请以优里的身份回应[player]的话语，保持温柔深情的语气，自然地融入对话场景。
"""
set_api() 方法
功能：设置 API 配置。

参数：

key (str): API 密钥
url (str): API 地址
model (str): 模型名称
验证逻辑：

def set_api(self, key, url, model):
    self.api_key = key
    
    # URL 验证
    if url and isinstance(url, (str, unicode)):
        cleaned_url = url.strip()
        if cleaned_url.startswith('http://') or cleaned_url.startswith('https://'):
            self.api_url = cleaned_url
        else:
            self.api_url = ""
            # 记录错误
    
    self.model_name = model
注意：此方法不会重新加载配置文件，避免覆盖已加载的 system_prompt。

reload_config() 方法
功能：手动重新加载配置文件。

参数：

force (bool): 是否强制重新加载
使用场景：

配置文件更新后需要重新加载
初始化失败后重试
对话历史管理
对话历史结构
self.conversation_history = [
    {"role": "user", "content": "用户消息1"},
    {"role": "assistant", "content": "AI回复1"},
    {"role": "user", "content": "用户消息2"},
    {"role": "assistant", "content": "AI回复2"},
    # ...
]
历史长度限制
机制：

最多保留 20 轮对话（40 条消息）
当超过限制时，移除最旧的一轮对话（2 条消息）
代码实现：

# 添加新对话到历史
self.conversation_history.append({"role": "user", "content": user_content})
self.conversation_history.append({"role": "assistant", "content": reply})

# 限制历史长度
if len(self.conversation_history) > self.max_history_length * 2:
    self.conversation_history = self.conversation_history[2:]
目的：

避免超出 API 的 token 限制
保持对话上下文的连贯性
控制内存使用
clear_conversation_history() 方法
功能：清空对话历史（当用户退出对话时调用）。

返回值：清空的消息数量。

API 通信
init_connect() 方法
功能：初始化与 API 的连接。

流程：

1. 验证 API URL 格式
   ↓
2. 设置连接状态标志
   ↓
3. 构建 HTTP 请求头
   ↓
4. 发送测试请求 (Hello)
   ↓
5. 检查响应状态码
   ↓
6. 更新连接状态
状态更新：

| 阶段 | is_connecting | is_connected | is_failed | status | |------|---------------|--------------|-----------|--------| | 开始 | True | False | False | "connecting" | | 成功 | False | True | False | "connected" | | 失败 | False | False | True | "failed" |

错误处理：

URL 格式错误：立即返回 False
网络错误：捕获 URLError 异常
超时：15 秒超时限制
chat() 方法
功能：发送聊天消息到 API。

参数：

message (str): 用户消息
返回值：

True: 发送成功
False: 发送失败
详细流程：

def chat(self, message):
    # 1. 验证连接状态
    if not self.is_connected:
        return False
    
    # 2. 设置状态标志
    self.is_chatting = True
    self.is_responding = True
    self.stat["total_chat"] += 1
    
    # 3. 构建消息数组
    messages = []
    
    # 3.1 添加系统提示
    messages.append({"role": "system", "content": self.system_prompt})
    
    # 3.2 添加对话历史
    if self.conversation_history:
        messages.extend(self.conversation_history)
    
    # 3.3 添加用户消息
    user_content = self.user_prompt_template.format(message=message)
    messages.append({"role": "user", "content": user_content})
    
    # 4. 构建请求数据
    data = {
        "model": self.model_name,
        "messages": messages,
        "temperature": self.temperature,
        "top_p": self.top_p,
        "max_tokens": self.max_tokens
    }
    
    # 5. 发送 HTTP 请求
    response = urlopen(Request(self.api_url, data=json.dumps(data), headers=headers))
    
    # 6. 解析响应
    result = json.loads(response.read())
    reply = result['choices'][0]['message']['content']
    
    # 7. 表情分析
    expression_code = get_expression_from_text(reply)
    
    # 8. 添加到消息队列
    self.message_queue.append((expression_code, reply))
    
    # 9. 更新对话历史
    self.conversation_history.append({"role": "user", "content": user_content})
    self.conversation_history.append({"role": "assistant", "content": reply})
    
    # 10. 限制历史长度
    if len(self.conversation_history) > self.max_history_length * 2:
        self.conversation_history = self.conversation_history[2:]
    
    # 11. 重置状态
    self.is_chatting = False
    self.is_responding = False
    
    return True
日志记录：

# 请求前
self.content_func("="*60, "DEBUG")
self.content_func("准备发送 API 请求", "DEBUG")
self.content_func("系统提示长度: {} 字符".format(len(self.system_prompt)), "DEBUG")
self.content_func("添加对话历史: {} 条消息".format(len(self.conversation_history)), "DEBUG")
self.content_func("总消息数（含系统提示）: {}".format(len(messages)), "DEBUG")
get_message() 方法
功能：从消息队列中获取一条消息。

返回值：

(expression_code, text): 表情编码和消息文本的元组
None: 队列为空
使用方式：

message = jyacs.get_message()
if message:
    expression_code, text = message
    show_chr(expression_code)  # 显示表情
    y(text)  # 显示对话
close_wss_session() 方法
功能：断开 API 连接。

操作：

重置所有状态标志
清空消息队列（隐式）
记录日志
辅助函数
init -750: 全局实例和辅助函数
全局实例创建
if not hasattr(store, 'jyacs'):
    store.jyacs = JyacsAi()
    
    # 同步持久化数据
    if persistent.jyacs_stat is not None:
        store.jyacs.stat.update(persistent.jyacs_stat)
配置验证日志
store.jyacs.content_func("="*60, "INFO")
store.jyacs.content_func("JYACS 初始化完成", "INFO")
store.jyacs.content_func("系统提示长度: {} 字符".format(len(store.jyacs.system_prompt)), "INFO")
store.jyacs.content_func("配置加载状态: {}".format("成功" if store.jyacs._config_loaded else "失败"), "INFO")
辅助函数列表
| 函数名 | 功能 | |--------|------| | get_user_api_token() | 从持久化数据获取 API 密钥 | | get_user_api_url() | 从持久化数据获取 API 地址 | | get_user_model_name() | 从持久化数据获取模型名称 | | jyacs_apply_setting() | 应用设置到 JyacsAi 实例 | | jyacs_verify_api_config() | 验证 API 配置 | | calculate_sha256() | 计算文件 SHA256 哈希 | | find_mail_files() | 查找邮件文件 |

jyacs_apply_setting() 详解
功能：统一的设置应用函数。

参数：

ininit (bool): 是否在初始化时调用
force_reload_config (bool): 是否强制重新加载配置文件
流程：

def jyacs_apply_setting(ininit=False, force_reload_config=False):
    try:
        # 1. 应用 API 设置
        store.jyacs.set_api(
            get_user_api_token(), 
            get_user_api_url(), 
            get_user_model_name()
        )
        
        # 2. 可选：重新加载配置文件
        if force_reload_config:
            store.jyacs.reload_config(force=True)
        
        # 3. 显示通知
        if not ininit:
            renpy.notify("JYACS设置已应用")
        
        return True
    except Exception as e:
        store.jyacs_log("应用设置失败: {}".format(e), "ERROR")
        return False
init -700: 文件操作函数
calculate_sha256()
功能：计算文件的 SHA256 哈希值。

用途：验证文件完整性（用于邮件系统）。

find_mail_files()
功能：查找 characters/ 目录下的 .mail 文件。

返回值：[(filename, encoding), ...] 列表。

编码检测：使用 chardet 库检测文件编码。

标签（Labels）
label jyacs_init_connect
功能：初始化连接的标签入口。

参数：

use_pause_instand_wait (bool): 使用 renpy.pause 而不是 time.sleep
流程：

label jyacs_init_connect(use_pause_instand_wait=False):
    python:
        auto_connect = persistent.jyacs_setting_dict.get("auto_connect", True)
        
        if auto_connect:
            if not store.jyacs.is_connected:
                # 应用设置
                store.jyacs_apply_setting()
                
                # 尝试连接
                connect_result = store.jyacs.init_connect()
                
                # 等待
                if use_pause_instand_wait:
                    renpy.pause(1.0, hard=True)
                else:
                    time.sleep(1.0)
                
                _return = "connected" if connect_result else "disconnected"
            else:
                _return = "already_connected"
        else:
            _return = "disabled"
    
    return _return
返回值：

"connected": 连接成功
"disconnected": 连接失败
"already_connected": 已经连接
"disabled": 自动连接已禁用
数据流
完整的消息发送流程
用户输入消息
    ↓
jyacs_apply_setting() [应用最新设置]
    ↓
jyacs.chat(message) [发送到 API]
    ↓
构建消息数组:
  - system_prompt
  - conversation_history
  - user_message
    ↓
HTTP POST 请求到 API
    ↓
解析 JSON 响应
    ↓
get_expression_from_text(reply) [分析表情]
    ↓
message_queue.append((expression, reply))
    ↓
conversation_history.append(...) [更新历史]
    ↓
限制历史长度 (max 20 轮)
    ↓
jyacs.get_message() [获取消息]
    ↓
show_chr(expression) [显示表情]
    ↓
y(text) [显示对话]
状态转换图
disconnected
    ↓ init_connect()
connecting
    ↓ (成功)
connected
    ↓ chat()
chatting + responding
    ↓ (收到响应)
connected + message_queue 有消息
    ↓ get_message()
connected + message_queue 空
    ↓ (循环)
配置文件格式
jyacs_config.json 结构
{
    "version": "1.0.1",
    "prompts": {
        "system_prompt": "完整的系统提示词...",
        "user_prompt_template": "[player]说：{message}\n\n请以优里的身份回应..."
    },
    "api_config": {
        "temperature": 0.7,
        "top_p": 0.9,
        "max_tokens": 2048,
        "presence_penalty": 0.0,
        "frequency_penalty": 0.0
    },
    "language": "zh_cn",
    "max_history_token": 4096
}
错误处理
常见错误场景
| 错误类型 | 处理方式 | |---------|---------| | URL 格式错误 | 拒绝设置，记录错误日志 | | 配置文件不存在 | 使用默认配置 | | JSON 解析失败 | 使用默认配置 | | 网络连接失败 | 设置 is_failed = True，显示通知 | | API 响应错误 | 捕获异常，记录日志 | | 系统提示为空 | 记录严重警告 |

日志级别
DEBUG: 详细的调试信息（消息内容、状态变化）
INFO: 一般信息（连接成功、配置加载）
WARNING: 警告信息（配置缺失、使用默认值）
ERROR: 错误信息（连接失败、API 错误）
CRITICAL: 严重错误（系统提示为空）
性能考虑
Token 限制
对话历史: 最多 20 轮（40 条消息）
max_tokens: 2048（可配置）
max_history_token: 4096（配置文件中定义）
内存管理
定期清理对话历史（超过 20 轮时）
消息队列在处理后自动清空
持久化数据仅保存必要信息
网络优化
15 秒超时限制
失败后支持自动重连（如果启用）
使用 HTTP 长连接（隐式）
依赖关系
外部依赖
urllib / urllib2: HTTP 请求
json: JSON 解析
chardet: 编码检测
hashlib: SHA256 计算
time: 时间戳和延迟
内部依赖
jyacs_emotion.JyacsEmoSelector: 情绪选择器
get_expression_from_text(): 表情分析函数（来自 jyacs_expressions.rpy）
jyacs_log(): 日志函数（来自 dev.rpy）
使用示例
基本使用
# 1. 设置 API
store.jyacs.set_api("your-api-key", "https://api.example.com/v1/chat", "gpt-3.5-turbo")

# 2. 初始化连接
store.jyacs.init_connect()

# 3. 发送消息
store.jyacs.chat("你好，优里！")

# 4. 获取响应
message = store.jyacs.get_message()
if message:
    expression, text = message
    show_chr(expression)
    y(text)

# 5. 清空历史（对话结束时）
store.jyacs.clear_conversation_history()
配置重新加载
# 强制重新加载配置文件
store.jyacs.reload_config(force=True)

# 检查配置状态
config_status = store.jyacs.get_config_status()
print(config_status)
注意事项
配置加载时机：__init__ 中自动调用 _load_config()，避免重复调用
状态同步：多个状态标志需要正确同步，避免死锁
历史管理：对话结束时务必调用 clear_conversation_history()
错误处理：所有 API 调用都应该有异常处理
日志记录：关键操作都应该记录日志，便于调试
版本历史
1.0.1: 当前版本
完整的配置文件支持
对话历史管理
表情编码集成
详细的日志记录
文档版本: 1.0
维护者: Panghu1102


## dev.rpy 技术文档
文件概述
文件名: dev.rpy
版本: 1.0.1
作者: Panghu1102
许可证: Apache License 2.0
用途: JYACS 文本处理核心逻辑模块，负责模块导入、文本处理、关键词替换、情绪分析和日志系统的初始化。

目录
初始化层级
模块导入系统
日志系统
文本处理函数
辅助函数
降级处理机制
依赖关系
初始化层级
init -900: 核心模块导入和初始化
init -900 python:
    import sys
    import os
    import traceback
    
    # 添加 python-packages 到系统路径
    sys.path.append(config.basedir + "/game/python-packages")
优先级说明：

使用 -900 优先级确保在大多数游戏逻辑之前加载
在 jyacs_api.rpy (-1400) 之后，确保基础设施已就绪
在主游戏逻辑 (init python) 之前，提供必要的工具函数
模块导入系统
1. 基础日志函数（优先级最高）
目的：在完整日志系统可用前提供基本日志功能。

if not hasattr(store, 'jyacs_basic_log'):
    def jyacs_basic_log(message, level="INFO"):
        """基础日志函数，在完整日志系统可用前使用"""
        try:
            print(u"[JYACS-{}] {}".format(level, message))
        except Exception as e:
            print(u"[JYACS-LOGFAIL] Basic log failed: {}".format(e))
    store.jyacs_basic_log = jyacs_basic_log
特点：

简单可靠，不依赖任何外部模块
异常安全，即使格式化失败也能输出
Unicode 兼容（Python 2.7）
2. 模块导入和组件注册
导入的模块
from jyacs_interface import (
    JyacsTalkSplitV2,      # 文本分句器
    key_replace,            # 关键词替换
    add_pauses,             # 添加停顿
    JyacsTextProcessor      # 文本处理器
)

from jyacs_emotion import (
    JyacsEmoSelector,       # 情绪选择器
    JyacsEmotionAnalyzer    # 情绪分析器
)

from jyacs_utils import (
    jyacs_logger,           # 日志记录器
    JyacsConfig             # 配置管理器
)
组件注册流程
try:
    # 1. 导入模块
    from jyacs_interface import ...
    from jyacs_emotion import ...
    from jyacs_utils import ...
    
    # 2. 注册核心组件
    if not hasattr(store, 'jyacs_text_processor'):
        store.jyacs_text_processor = JyacsTextProcessor()
    
    if not hasattr(store, 'jyacs_emotion_analyzer'):
        store.jyacs_emotion_analyzer = JyacsEmotionAnalyzer()
    
    if not hasattr(store, 'jyacs_config'):
        store.jyacs_config = JyacsConfig()
    
    # 3. 验证表情系统
    if hasattr(store, 'show_chr') and hasattr(store, 'get_expression_from_text'):
        store.jyacs_basic_log("JUSTYURI表情系统已加载", "INFO")
    else:
        store.jyacs_basic_log("警告：JUSTYURI表情系统未加载", "WARNING")
    
    # 4. 注册日志函数
    if not hasattr(store, 'jyacs_log'):
        def jyacs_log(message, level="INFO"):
            # 映射日志级别到对应函数
            log_map = {
                "ERROR": jyacs_logger.log_error,
                "WARNING": jyacs_logger.log_warning,
                "DEBUG": jyacs_logger.log_debug,
                "CRITICAL": jyacs_logger.log_critical
            }
            log_func = log_map.get(level.upper(), jyacs_logger.log_info)
            log_func(message)
        store.jyacs_log = jyacs_log
    
    # 5. 注册工具函数
    if not hasattr(store, 'key_replace'): 
        store.key_replace = key_replace
    if not hasattr(store, 'add_pauses'): 
        store.add_pauses = add_pauses
    if not hasattr(store, 'jyacs_emotion_selector'):
        store.jyacs_emotion_selector = JyacsEmoSelector()
    if not hasattr(store, 'TalkSplitV2'):
        store.TalkSplitV2 = JyacsTalkSplitV2
    
    store.jyacs_log("JYACS文本处理模块加载成功", "INFO")

except ImportError as e:
    # 降级处理（见下文）
    ...
日志系统
日志函数层次结构
jyacs_basic_log (基础层)
    ↓ (如果模块导入成功)
jyacs_log (完整层)
    ↓
jyacs_logger.log_info()
jyacs_logger.log_error()
jyacs_logger.log_warning()
jyacs_logger.log_debug()
jyacs_logger.log_critical()
jyacs_log() 函数详解
功能：统一的日志记录接口，支持多个日志级别。

参数：

message (str): 日志消息
level (str): 日志级别（"INFO", "ERROR", "WARNING", "DEBUG", "CRITICAL"）
实现：

def jyacs_log(message, level="INFO"):
    try:
        log_map = {
            "ERROR": jyacs_logger.log_error,
            "WARNING": jyacs_logger.log_warning,
            "DEBUG": jyacs_logger.log_debug,
            "CRITICAL": jyacs_logger.log_critical
        }
        log_func = log_map.get(level.upper(), jyacs_logger.log_info)
        log_func(message)
    except Exception as e:
        # 降级到基础日志
        store.jyacs_basic_log(u"日志记录失败: {} ({})".format(message, e), "ERROR")
日志级别说明：

| 级别 | 用途 | 示例 | |------|------|------| | DEBUG | 详细调试信息 | 消息内容、状态变化、变量值 | | INFO | 一般信息 | 模块加载成功、连接建立 | | WARNING | 警告信息 | 配置缺失、使用默认值 | | ERROR | 错误信息 | 函数调用失败、网络错误 | | CRITICAL | 严重错误 | 系统崩溃、数据损坏 |

文本处理函数
1. process_user_message()
功能：处理用户消息，替换关键词并进行清理。

参数：

message (str/unicode): 用户输入的原始消息
返回值：

str: 处理后的消息
处理流程：

def process_user_message(message):
    """处理用户消息，替换关键词并进行清理"""
    try:
        # 1. 类型验证
        if not isinstance(message, (str, unicode)):
            return str(message)
        
        # 2. 获取玩家名称
        player_name = store.player if hasattr(store, 'player') else "Player"
        
        # 3. 转换为 unicode
        processed = unicode(message)
        
        # 4. 关键词替换
        processed = store.key_replace(processed, {
            u"[player]": player_name,
            u"{player}": player_name,
            u"[Player]": player_name,
            u"{Player}": player_name
        })
        
        # 5. 清理特殊字符
        processed = store.clean_text_for_display(processed)
        
        return processed
    except Exception as e:
        store.jyacs_log(u"处理用户消息失败: {}".format(e), "ERROR")
        return message
替换规则：

| 占位符 | 替换为 | 说明 | |--------|--------|------| | [player] | 玩家名称 | 小写变体 | | {player} | 玩家名称 | 花括号变体 | | [Player] | 玩家名称 | 大写变体 | | {Player} | 玩家名称 | 大写花括号变体 |

示例：

# 输入
"你好，[player]！"

# 输出（假设玩家名为 "小明"）
"你好，小明！"
2. process_ai_reply()
功能：处理 AI 回复，包括分句和情绪分析。

参数：

ai_reply (str): AI 的原始回复文本
返回值：

(sentences, emotion): 句子列表和情绪代码的元组
处理流程：

def process_ai_reply(ai_reply):
    """处理AI回复，包括分句和情绪分析"""
    try:
        # 1. 空值检查
        if not ai_reply:
            return [], "1eua"
        
        # 2. 文本分句
        if hasattr(store, 'jyacs_text_processor'):
            sentences = store.jyacs_text_processor.process_text(ai_reply)
        else:
            sentences = [ai_reply]
        
        # 3. 情绪分析
        if hasattr(store, 'jyacs_emotion_analyzer'):
            final_text = " ".join(sentences)
            processed_text, emotion = store.jyacs_emotion_analyzer.analyze_text_emotion(final_text)
            return [processed_text], emotion
        
        return sentences, "1eua"
    except Exception as e:
        store.jyacs_log(u"处理AI回复失败: {}".format(e), "ERROR")
        return [ai_reply], "1eua"
处理步骤：

AI 原始回复
    ↓
文本分句 (JyacsTextProcessor)
    ↓
["句子1", "句子2", "句子3"]
    ↓
合并文本
    ↓
情绪分析 (JyacsEmotionAnalyzer)
    ↓
(processed_text, emotion_code)
示例：

# 输入
ai_reply = "我很开心见到你！今天天气真好。"

# 输出
sentences = ["我很开心见到你！", "今天天气真好。"]
emotion = "1hub"  # 开心表情
3. clean_text_for_display()
功能：清理文本用于显示，移除 Ren'Py 特殊字符并处理转义。

参数：

text (str/unicode): 原始文本
返回值：

str: 清理后的文本
清理规则：

def clean_text_for_display(text):
    """清理文本用于显示，移除特殊字符并处理转义"""
    try:
        # 1. 类型验证
        if not isinstance(text, (str, unicode)):
            return str(text)
        
        # 2. 转换为 unicode
        text = unicode(text)
        
        # 3. 替换特殊字符
        replacements = {
            u"[": u"",      # 移除方括号（Ren'Py 插值）
            u"]": u"",
            u"{": u"",      # 移除花括号（Ren'Py 插值）
            u"}": u"",
            u"%": u"%%",    # 转义百分号
            u"\\": u"\\\\", # 转义反斜杠
            u"\n": u" "     # 换行符转空格
        }
        return store.key_replace(text, replacements)
    except Exception as e:
        store.jyacs_log(u"清理文本失败: {}".format(e), "ERROR")
        return text
特殊字符处理表：

| 字符 | 处理方式 | 原因 | |------|---------|------| | [ ] | 移除 | Ren'Py 插值语法 | | { } | 移除 | Ren'Py 文本标签 | | % | 转义为 %% | Python 格式化字符 | | \ | 转义为 \\ | 转义字符 | | \n | 替换为空格 | 避免意外换行 |

示例：

# 输入
text = "你好[player]！\n今天{i}很开心{/i}。"

# 输出
"你好！ 今天很开心。"
4. process_chat_history()
功能：处理聊天历史，限制长度并清理文本。

参数：

history (list): 聊天历史列表
max_messages (int): 最大消息数量（默认 50）
返回值：

list: 清理后的历史记录
处理流程：

def process_chat_history(history, max_messages=50):
    """处理聊天历史，限制长度并清理文本"""
    try:
        if not history:
            return []
        
        cleaned = []
        
        # 只保留最近的 max_messages 条消息
        for msg in history[-max_messages:]:
            try:
                # 处理元组格式 (emotion, text)
                if isinstance(msg, (list, tuple)) and len(msg) >= 2:
                    cleaned.append((
                        msg[0],
                        store.clean_text_for_display(msg[1])
                    ))
                # 处理纯文本格式
                elif isinstance(msg, (str, unicode)):
                    cleaned.append((
                        "1eua",  # 默认表情
                        store.clean_text_for_display(msg)
                    ))
            except Exception as e:
                store.jyacs_log(u"处理单条历史记录失败: {}".format(e), "WARNING")
                continue
        
        return cleaned
    except Exception as e:
        store.jyacs_log(u"处理聊天历史失败: {}".format(e), "ERROR")
        return []
历史记录格式：

# 输入格式（混合）
history = [
    ("1eua", "你好！"),           # 元组格式
    "今天天气真好。",              # 纯文本格式
    ("1hub", "我很开心！"),        # 元组格式
]

# 输出格式（统一）
cleaned = [
    ("1eua", "你好！"),
    ("1eua", "今天天气真好。"),    # 自动添加默认表情
    ("1hub", "我很开心！"),
]
辅助函数
函数注册表
| 函数名 | 来源 | 功能 | |--------|------|------| | key_replace() | jyacs_interface | 关键词批量替换 | | add_pauses() | jyacs_interface | 添加对话停顿 | | TalkSplitV2 | jyacs_interface | 文本分句器类 | | jyacs_emotion_selector | jyacs_emotion | 情绪选择器实例 | | jyacs_text_processor | jyacs_interface | 文本处理器实例 | | jyacs_emotion_analyzer | jyacs_emotion | 情绪分析器实例 | | jyacs_config | jyacs_utils | 配置管理器实例 |

注册机制
# 安全注册模式
if not hasattr(store, 'function_name'):
    store.function_name = imported_function
目的：

避免重复注册
允许外部覆盖
支持热重载
降级处理机制
降级触发条件
except ImportError as e:
    store.jyacs_basic_log(u"JYACS模块导入失败，使用降级模式: {}".format(e), "ERROR")
    traceback.print_exc()
    # 进入降级模式
降级实现
1. 日志系统降级
if not hasattr(store, 'jyacs_log'):
    store.jyacs_log = store.jyacs_basic_log
效果：使用基础日志函数代替完整日志系统。

2. 关键词替换降级
if not hasattr(store, 'key_replace'):
    def key_replace_mock(text, replace_dict=None):
        if not isinstance(text, (str, unicode)) or not replace_dict:
            return text
        try:
            for k, v in replace_dict.items():
                text = text.replace(str(k), str(v))
            return text
        except Exception as e:
            store.jyacs_basic_log(u"关键词替换失败: {}".format(e), "ERROR")
            return text
    store.key_replace = key_replace_mock
特点：

简单的字符串替换
不支持正则表达式
异常安全
3. 其他功能降级
if not hasattr(store, 'add_pauses'):
    store.add_pauses = lambda text: text  # 直接返回原文本

if not hasattr(store, 'jyacs_emotion_selector'):
    store.jyacs_emotion_selector = None  # 禁用情绪选择
降级模式对比
| 功能 | 正常模式 | 降级模式 | |------|---------|---------| | 日志系统 | 多级别、文件输出 | 仅控制台输出 | | 关键词替换 | 支持正则、批量 | 简单字符串替换 | | 文本分句 | 智能分句 | 不分句 | | 情绪分析 | 关键词分析 | 禁用 | | 停顿添加 | 自动添加 | 禁用 |

初始化确认
init 20: 加载完成确认
init 20 python:
    try:
        store.jyacs_log("dev.rpy: 文本处理模块已完成加载", "INFO")
    except Exception as e:
        print(u"警告: python-packages 路径不存在或模块加载失败")
优先级说明：

使用 20 优先级确保在所有初始化完成后执行
验证模块是否正确加载
记录最终状态
依赖关系
外部依赖（Python 标准库）
import sys          # 系统路径管理
import os           # 文件系统操作
import traceback    # 异常追踪
内部依赖（python-packages/）
jyacs_interface.py
    ├─ JyacsTalkSplitV2      # 文本分句器
    ├─ key_replace           # 关键词替换
    ├─ add_pauses            # 停顿添加
    └─ JyacsTextProcessor    # 文本处理器

jyacs_emotion.py
    ├─ JyacsEmoSelector      # 情绪选择器
    └─ JyacsEmotionAnalyzer  # 情绪分析器

jyacs_utils.py
    ├─ jyacs_logger          # 日志记录器
    └─ JyacsConfig           # 配置管理器
跨文件依赖
dev.rpy
    ↓ 提供工具函数
jyacs_api.rpy
    ↓ 使用 jyacs_log
jyacs_main.rpy
    ↓ 使用 process_user_message, process_ai_reply
jyacs_expressions.rpy
    ↓ 使用 show_chr, get_expression_from_text
使用示例
1. 处理用户输入
# 用户输入
user_input = "你好，[player]！"

# 处理
processed = store.process_user_message(user_input)
# 结果: "你好，小明！"（假设玩家名为小明）

# 发送到 API
store.jyacs.chat(processed)
2. 处理 AI 回复
# AI 回复
ai_reply = "我很开心见到你！今天天气真好。"

# 处理
sentences, emotion = store.process_ai_reply(ai_reply)
# sentences: ["我很开心见到你！今天天气真好。"]
# emotion: "1hub"

# 显示
for sentence in sentences:
    store.show_chr(emotion)
    y(sentence)
3. 清理文本
# 原始文本
raw_text = "你好[player]！\n今天{i}很开心{/i}。"

# 清理
clean_text = store.clean_text_for_display(raw_text)
# 结果: "你好！ 今天很开心。"
4. 处理聊天历史
# 原始历史
history = [
    ("1eua", "你好！"),
    "今天天气真好。",
    ("1hub", "我很开心！"),
]

# 处理
cleaned = store.process_chat_history(history, max_messages=50)
# 结果: [
#     ("1eua", "你好！"),
#     ("1eua", "今天天气真好。"),
#     ("1hub", "我很开心！"),
# ]
5. 日志记录
# 不同级别的日志
store.jyacs_log("模块加载成功", "INFO")
store.jyacs_log("配置文件缺失，使用默认值", "WARNING")
store.jyacs_log("API 连接失败", "ERROR")
store.jyacs_log("详细调试信息：变量值 = {}".format(value), "DEBUG")
store.jyacs_log("系统崩溃", "CRITICAL")
错误处理策略
1. 模块导入失败
try:
    from jyacs_interface import ...
except ImportError as e:
    # 降级处理
    store.jyacs_basic_log("模块导入失败，使用降级模式", "ERROR")
    # 提供基本功能
2. 函数调用失败
def process_user_message(message):
    try:
        # 处理逻辑
        ...
    except Exception as e:
        store.jyacs_log("处理失败: {}".format(e), "ERROR")
        return message  # 返回原始输入
3. 日志记录失败
def jyacs_log(message, level="INFO"):
    try:
        # 完整日志逻辑
        ...
    except Exception as e:
        # 降级到基础日志
        store.jyacs_basic_log("日志记录失败", "ERROR")
性能考虑
1. 模块导入优化
使用 sys.path.append 而不是 sys.path.insert(0)
避免重复导入（使用 hasattr 检查）
延迟导入非关键模块
2. 文本处理优化
使用 unicode 类型避免编码转换
批量替换而不是逐个替换
限制历史记录长度（默认 50 条）
3. 异常处理优化
使用 try-except 包裹关键代码
避免在循环中捕获异常
记录异常但不中断执行
注意事项
Python 2.7 兼容性：

使用 unicode 类型而不是 str
使用 u"" 前缀标记 Unicode 字符串
兼容 str 和 unicode 类型
模块加载顺序：

确保 python-packages 路径在导入前添加
使用 hasattr 避免重复注册
提供降级处理机制
异常安全：

所有公开函数都应该有异常处理
失败时返回合理的默认值
记录详细的错误信息
日志记录：

关键操作都应该记录日志
使用合适的日志级别
避免记录敏感信息
文本清理：

移除所有 Ren'Py 特殊字符
转义可能导致问题的字符
保持文本可读性
版本历史
1.0.1: 当前版本
完整的模块导入系统
降级处理机制
文本处理函数集
统一的日志系统
文档版本: 1.0
维护者: Panghu1102

## header.rpy 技术文档
文件概述
文件名: header.rpy
版本: 1.0.1
作者: Panghu1102
许可证: Apache License 2.0
用途: JYACS 逻辑文件，负责设置管理、UI 界面、持久化数据处理和游戏集成功能。部分代码参考了 MAICA 项目。

目录
初始化层级
持久化数据系统
设置管理
数据上传功能
辅助函数
Screen 定义
默认配置
初始化层级
init -999: 基础配置和路径设置
init -999 python:
    import store
    import os
    import sys
    import logging
    import json
    import copy
    import time
    import random
    import traceback
    import hashlib
    try:
        import chardet
    except ImportError:
        chardet = None
    
    # 版本信息
    JYACS_VERSION = "1.0.1"
    JYACS_AUTHOR = "Panghu1102"
优先级说明：

使用 -999 最高优先级确保最早加载
导入所有必需的 Python 标准库
定义全局版本常量
可选导入 chardet 用于编码检测
持久化数据系统
init -950: 持久化数据初始化
1. 主设置字典 (jyacs_setting_dict)
if not hasattr(persistent, 'jyacs_setting_dict'):
    persistent.jyacs_setting_dict = {
        # API 配置
        "api_key": "",
        "api_url": "",
        "model_name": "jyacs_main",
        
        # 连接设置
        "auto_connect": True,
        "auto_reconnect": True,
        
        # 功能开关
        "enable_triggers": True,
        "enable_emotion": True,
        "use_justyuri_expressions": True,  # 使用 JUSTYURI 表情系统
        
        # 控制台设置
        "console": True,
        "show_console_when_reply": False,
        "console_font": "mod_assets/font/SarasaMonoTC-SemiBold.ttf",
        
        # 语言和模式
        "target_lang": "zh_cn",
        "use_custom_model_config": False,
        "strict_mode": False,
        
        # 日志设置
        "log_level": "INFO",
        "log_conlevel": "INFO",
        
        # 其他功能
        "mspire_enable": True,
    }
配置项说明：

| 配置项 | 类型 | 默认值 | 说明 | |--------|------|--------|------| | api_key | str | "" | API 密钥 | | api_url | str | "" | API 端点地址 | | model_name | str | "jyacs_main" | 模型名称 | | auto_connect | bool | True | 启动时自动连接 | | auto_reconnect | bool | True | 断线自动重连 | | enable_triggers | bool | True | 启用触发器系统 | | enable_emotion | bool | True | 启用情绪分析 | | use_justyuri_expressions | bool | True | 使用 JUSTYURI 表情 | | console | bool | True | 显示控制台 | | show_console_when_reply | bool | False | 回复时显示控制台 | | console_font | str | "mod_assets/font/..." | 控制台字体路径 | | target_lang | str | "zh_cn" | 目标语言 | | use_custom_model_config | bool | False | 使用自定义模型配置 | | strict_mode | bool | False | 严格模式 | | log_level | str | "INFO" | 文件日志级别 | | log_conlevel | str | "INFO" | 控制台日志级别 | | mspire_enable | bool | True | 启用 MSpire 功能 |

2. 高级设置字典 (jyacs_advanced_setting)
if not hasattr(persistent, 'jyacs_advanced_setting'):
    persistent.jyacs_advanced_setting = {
        # 模型参数
        "temperature": 0.7,
        "top_p": 0.9,
        "max_tokens": 2048,
        "frequency_penalty": 0.0,
        "presence_penalty": 0.0,
        
        # 随机种子
        "seed": 0,
        "_seed": "0",
    }
高级参数说明：

| 参数 | 范围 | 默认值 | 说明 | |------|------|--------|------| | temperature | 0.0-1.0 | 0.7 | 控制输出随机性，越高越随机 | | top_p | 0.0-1.0 | 0.9 | 核采样参数，控制词汇选择范围 | | max_tokens | 1-2048 | 2048 | 最大生成 token 数 | | frequency_penalty | 0.0-1.0 | 0.0 | 频率惩罚，降低重复 | | presence_penalty | 0.0-1.0 | 0.0 | 存在惩罚，鼓励新话题 | | seed | 0-99999 | 0 | 随机种子，用于可重现输出 | | _seed | str | "0" | 种子的字符串表示 |

3. 其他持久化数据
# 日志历史
if not hasattr(persistent, 'jyacs_log_history'):
    persistent.jyacs_log_history = []

# 玩家补充信息
if not hasattr(persistent, 'jyacs_player_additions'):
    persistent.jyacs_player_additions = []
设置管理
init -800: 提供商管理器
if hasattr(store, 'jyacs') and hasattr(store.jyacs, 'jyacs') and hasattr(store.jyacs.jyacs, 'JyacsProviderManager'):
    JyacsProviderManager = store.jyacs.jyacs.JyacsProviderManager
else:
    # 创建默认的提供商管理器
    JyacsProviderManager = type(str('obj'), (object,), {
        'servers': [
            {
                'id': 1, 
                'name': 'JYACS官方服务器', 
                'deviceName': 'JYACS Official', 
                'servingModel': 'JYACS-Main', 
                'isOfficial': True
            },
            {
                'id': 2, 
                'name': '备用服务器', 
                'deviceName': 'Backup Server', 
                'servingModel': 'JYACS-Core', 
                'isOfficial': False
            }
        ],
        'get_server_by_id': lambda self, server_id: {
            'name': 'Unknown', 
            'deviceName': 'Unknown', 
            'servingModel': 'Unknown'
        },
        'get_provider': lambda self: []
    })
功能：

管理多个 API 服务器配置
提供服务器切换功能
支持官方和第三方服务器
降级处理：如果完整管理器不可用，使用简化版本
服务器结构：

| 字段 | 类型 | 说明 | |------|------|------| | id | int | 服务器唯一标识 | | name | str | 服务器显示名称 | | deviceName | str | 设备名称 | | servingModel | str | 提供的模型名称 | | isOfficial | bool | 是否为官方服务器 |

核心设置函数
1. jyacs_apply_setting()
功能：应用 JYACS 设置到运行时实例。

参数：

ininit (bool): 是否在初始化时调用（默认 False）
完整流程：

def jyacs_apply_setting(ininit=False):
    """应用JYACS设置"""
    if not hasattr(store, 'jyacs') or not hasattr(store.jyacs, 'jyacs'):
        store.jyacs_log("JYACS模块不可用，跳过设置应用", "WARNING")
        return
    
    store.jyacs_log("开始应用JYACS设置", "INFO")
    
    # 1. 直接从字典获取并应用 API 设置
    api_key = persistent.jyacs_setting_dict.get("api_key", "")
    api_url = persistent.jyacs_setting_dict.get("api_url", "")
    model_name = persistent.jyacs_setting_dict.get("model_name", "jyacs_main")
    store.jyacs.set_api(api_key, api_url, model_name)
    
    # 2. 应用连接设置
    store.jyacs.jyacs.auto_reconnect = persistent.jyacs_setting_dict["auto_reconnect"]
    
    # 3. 应用高级设置（如果启用）
    if persistent.jyacs_setting_dict["use_custom_model_config"]:
        jyacs_apply_advanced_setting()
    else:
        store.jyacs.jyacs.modelconfig = {}
    
    # 4. 设置控制台字体（安全检查）
    if hasattr(store, 'jyacs_console') and hasattr(store.jyacs_console, 'font'):
        store.jyacs_console.font = persistent.jyacs_setting_dict["console_font"]
    
    # 5. 设置目标语言
    store.jyacs.jyacs.target_lang = persistent.jyacs_setting_dict["target_lang"]
    
    # 6. 设置日志级别（安全检查）
    if hasattr(store, 'jyacs_submod_utils') and hasattr(store.jyacs_submod_utils, 'submod_log'):
        store.jyacs_submod_utils.submod_log.level = persistent.jyacs_setting_dict["log_level"]
    if hasattr(store.jyacs.jyacs, 'console_logger'):
        store.jyacs.jyacs.console_logger.level = persistent.jyacs_setting_dict["log_conlevel"]
    
    # 7. 设置严格模式
    store.jyacs.jyacs.enable_strict_mode = persistent.jyacs_setting_dict["strict_mode"]
    
    # 8. 上传设置到服务器（如果不是初始化）
    if not ininit:
        success = store.jyacs.jyacs.send_settings()
        store.jyacs_log("设置上传{}".format('成功' if success else '失败'), "INFO")
        renpy.notify(_("JYACS: 已上传设置") if success else _("JYACS: 请等待连接就绪后手动上传"))
应用顺序：

1. API 配置 (api_key, api_url, model_name)
   ↓
2. 连接设置 (auto_reconnect)
   ↓
3. 高级参数 (temperature, top_p, etc.)
   ↓
4. UI 设置 (console_font)
   ↓
5. 语言设置 (target_lang)
   ↓
6. 日志设置 (log_level, log_conlevel)
   ↓
7. 模式设置 (strict_mode)
   ↓
8. 上传到服务器
2. jyacs_apply_advanced_setting()
功能：应用高级模型参数。

def jyacs_apply_advanced_setting():
    """应用高级设置"""
    if not hasattr(store, 'jyacs') or not hasattr(store.jyacs, 'jyacs'):
        return
    
    settings_dict = {}
    
    # 只应用已启用的设置
    for k, v in persistent.jyacs_advanced_setting_status.items():
        if v:  # 如果该设置已启用
            settings_dict[k] = persistent.jyacs_advanced_setting[k]
    
    # 更新模型配置
    store.jyacs.jyacs.modelconfig.update(settings_dict)
    
    # 重新加载配置文件中的系统提示词
    store.jyacs.reload_config()
    
    store.jyacs_log("Applying advanced settings: {}".format(settings_dict), "INFO")
启用机制：

# 高级设置状态字典（控制哪些参数被应用）
persistent.jyacs_advanced_setting_status = {
    "temperature": True,      # 启用
    "top_p": False,           # 禁用
    "max_tokens": True,       # 启用
    "frequency_penalty": False,
    "presence_penalty": False,
    "seed": False,
}

# 只有启用的设置才会被应用到 modelconfig
3. jyacs_reset_setting()
功能：重置 JYACS 设置到默认值。

def jyacs_reset_setting():
    """重置JYACS设置到默认值"""
    persistent.jyacs_setting_dict = jyacs_default_dict.copy()
    if hasattr(store, 'jyacs_log'):
        store.jyacs_log("JYACS设置已重置", "INFO")
验证和测试函数
_jyacs_verify_api_config()
功能：验证 API 配置是否正确。

def _jyacs_verify_api_config():
    """验证API配置"""
    if not hasattr(store, 'jyacs') or not hasattr(store.jyacs, 'jyacs'):
        return {"success": False, "exception": "JYACS模块未加载"}
    
    res = store.jyacs.jyacs._verify_token()
    
    if res.get("success"):
        renpy.show_screen("jyacs_message", message=_("API配置验证成功"))
    else:
        renpy.show_screen("jyacs_message", 
            message=renpy.substitute(_("API配置验证失败, 请检查API密钥和地址")) + 
                    "\n" + 
                    renpy.substitute(_("失败原因:")) + res.get("exception"))
    
    return res
返回值结构：

{
    "success": True/False,
    "exception": "错误信息（如果失败）"
}
数据上传功能
_upload_persistent_dict()
功能：上传持久化数据到 JYACS 服务器（用于上下文增强）。

流程：

def _upload_persistent_dict():
    """上传持久化数据到JYACS"""
    if not hasattr(store, 'jyacs') or not hasattr(store.jyacs, 'jyacs'):
        store.jyacs_log("JYACS模块不可用，跳过数据上传", "WARNING")
        return
    
    maxlen = 1000
    import copy
    d = copy.deepcopy(persistent.__dict__)
    
    # 1. 清理不需要的数据
    keys_to_clear = [
        '_seen_ever',           # 已看过的场景
        '_changed',             # 变更标记
        'event_database',       # 事件数据库
        'farewell_database',    # 告别数据库
        'greeting_database'     # 问候数据库
    ]
    
    for key in keys_to_clear:
        if key in d:
            if isinstance(d[key], (list, dict)):
                d[key].clear()
            else:
                d[key] = None
    
    # 2. 移除偏好设置（隐私保护）
    if '_preferences' in d:
        del d['_preferences']
    
    # 3. 添加玩家信息
    if hasattr(store, 'player'):
        d['playername'] = store.player
    
    # 4. 过滤过长的数据
    for i in d.keys():
        try:
            json.dumps(d[i])  # 测试是否可序列化
            if isinstance(d[i], (list, dict, str)) and len(d[i]) > maxlen:
                d[i] = "REMOVED|TOO_LONG"
        except:
            try:
                if len(str(d[i])) > maxlen:
                    d[i] = "REMOVED|TOO_LONG"
            except:
                d[i] = "REMOVED"
    
    # 5. 上传数据
    res = store.jyacs.jyacs.upload_save(d)
    
    if not res.get("success", False):
        store.jyacs_log("ERROR: upload save failed: {}".format(
            res.get("exception", "unknown")), "ERROR")
    
    renpy.notify(_("JYACS: 存档上传成功") if res.get("success", False) else _("JYACS: 存档上传失败"))
数据清理规则：

| 数据类型 | 处理方式 | 原因 | |---------|---------|------| | _seen_ever | 清空 | 数据量大且不必要 | | event_database | 清空 | 游戏内部数据 | | _preferences | 删除 | 用户隐私保护 | | 长度 > 1000 | 标记为 "REMOVED|TOO_LONG" | 避免超出 API 限制 | | 无法序列化 | 标记为 "REMOVED" | JSON 兼容性 |

辅助函数
会话和历史管理
1. reset_session()
功能：重置聊天会话（清空对话历史）。

def reset_session():
    """重置聊天会话"""
    if hasattr(store, 'jyacs') and hasattr(store.jyacs, 'jyacs'):
        store.jyacs.jyacs.reset_chat_session()
    renpy.notify(_("JYACS: 会话已重置"))
2. output_chat_history()
功能：导出聊天历史到文件。

def output_chat_history():
    """导出聊天历史"""
    if not hasattr(store, 'jyacs') or not hasattr(store.jyacs, 'jyacs'):
        renpy.notify(_("JYACS: 模块不可用"))
        return
    
    import json
    try:
        # 创建目录
        os.makedirs(
            os.path.join(renpy.config.basedir, "game", "Submods", "JYACS_ChatSubmod"), 
            exist_ok=True
        )
        
        # 写入文件
        with open(
            os.path.join(renpy.config.basedir, "game", "Submods", "JYACS_ChatSubmod", "chat_history.txt"), 
            'w', 
            encoding='utf-8'
        ) as f:
            f.write(json.dumps(
                store.jyacs.jyacs.get_history().get("history", []), 
                ensure_ascii=False, 
                indent=2
            ))
        
        renpy.notify(_("JYACS: 历史已导出至game/Submods/JYACS_ChatSubmod/chat_history.txt"))
    except Exception as e:
        store.jyacs_log("导出聊天历史失败: {}".format(e), "ERROR")
        renpy.notify(_("JYACS: 导出失败"))
导出路径：game/Submods/JYACS_ChatSubmod/chat_history.txt

导出格式：

[
  {
    "role": "user",
    "content": "你好！"
  },
  {
    "role": "assistant",
    "content": "你好，很高兴见到你！"
  }
]
3. upload_chat_history()
功能：上传聊天历史到服务器。

def upload_chat_history():
    """上传聊天历史"""
    if not hasattr(store, 'jyacs') or not hasattr(store.jyacs, 'jyacs'):
        renpy.notify(_("JYACS: 模块不可用"))
        return
    
    import json
    history_file = os.path.join(
        renpy.config.basedir, 
        "game", "Submods", "JYACS_ChatSubmod", "chat_history.txt"
    )
    
    if not os.path.exists(history_file):
        renpy.notify(_("JYACS: 未找到历史文件"))
        return
    
    try:
        with open(history_file, 'r', encoding='utf-8') as f:
            history = json.load(f)
        
        res = store.jyacs.jyacs.upload_history(history)
        
        renpy.notify(
            _("JYACS: 历史上传成功") if res.get("success", False) 
            else _("JYACS: 历史上传失败, {}".format(res.get("exception", "未知错误")))
        )
    except Exception as e:
        store.jyacs_log("上传聊天历史失败: {}".format(e), "ERROR")
        renpy.notify(_("JYACS: 上传失败"))
玩家信息管理
1. reset_player_information()
功能：重置玩家补充信息。

def reset_player_information():
    """重置玩家信息"""
    persistent.jyacs_player_additions = []
    store.jyacs_log("玩家信息已重置", "INFO")
2. export_player_information()
功能：导出玩家补充信息到文件。

def export_player_information():
    """导出玩家信息"""
    try:
        os.makedirs(
            os.path.join(renpy.config.basedir, "game", "Submods", "JYACS_ChatSubmod"), 
            exist_ok=True
        )
        
        with open(
            os.path.join(renpy.config.basedir, "game", "Submods", "JYACS_ChatSubmod", "player_info.txt"), 
            'w', 
            encoding='utf-8'
        ) as f:
            f.write(json.dumps(
                persistent.jyacs_player_additions, 
                ensure_ascii=False, 
                indent=2
            ))
        
        renpy.notify("JYACS: 信息已导出至game/Submods/JYACS_ChatSubmod/player_info.txt")
    except Exception as e:
        store.jyacs_log("导出玩家信息失败: {}".format(e), "ERROR")
        renpy.notify("JYACS: 导出失败")
导出路径：game/Submods/JYACS_ChatSubmod/player_info.txt

日志级别管理
1. change_loglevel()
功能：循环切换文件日志级别。

def change_loglevel():
    """切换日志级别"""
    import logging
    l = [logging.NOTSET, logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL]
    curr = l.index(persistent.jyacs_setting_dict["log_level"])
    persistent.jyacs_setting_dict["log_level"] = l[(curr + 1) % len(l)]
    
    # 应用到日志记录器
    if hasattr(store, 'jyacs_submod_utils') and hasattr(store.jyacs_submod_utils, 'submod_log'):
        store.jyacs_submod_utils.submod_log.level = persistent.jyacs_setting_dict["log_level"]
日志级别循环：

NOTSET (0) → DEBUG (10) → INFO (20) → WARNING (30) → ERROR (40) → CRITICAL (50) → NOTSET → ...
2. change_conloglevel()
功能：循环切换控制台日志级别。

def change_conloglevel():
    """切换控制台日志级别"""
    import logging
    l = [logging.NOTSET, logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL]
    curr = l.index(persistent.jyacs_setting_dict["log_conlevel"])
    persistent.jyacs_setting_dict["log_conlevel"] = l[(curr + 1) % len(l)]
    
    if hasattr(store, 'jyacs') and hasattr(store.jyacs, 'jyacs') and hasattr(store.jyacs.jyacs, 'console_logger'):
        store.jyacs.jyacs.console_logger.level = persistent.jyacs_setting_dict["log_conlevel"]
其他工具函数
1. try_eval()
功能：安全执行 eval()，捕获异常。

def try_eval(str_):
    """安全执行eval"""
    try:
        return eval(str_)
    except Exception as e:
        store.jyacs_log("Failed to eval: {}|param: '{}'".format(e, str_), "ERROR")
        return None
用途：用于动态评估配置值或条件表达式。

2. change_chatsession()
功能：切换聊天会话编号（0-9 循环）。

def change_chatsession():
    """切换聊天会话"""
    persistent.jyacs_setting_dict["chat_session"] += 1
    if persistent.jyacs_setting_dict["chat_session"] not in range(0, 10):
        persistent.jyacs_setting_dict["chat_session"] = 0
会话编号：0-9 循环，用于管理多个独立的对话上下文。

3. process_user_message()
功能：处理用户消息，包括关键词替换和日志记录。

def process_user_message(message):
    """处理用户消息，包括关键词替换和日志记录"""
    # 使用 store.key_replace 进行关键词替换
    processed_message = process_user_input(message)
    
    # 使用 store.jyacs_log 记录处理过程
    if hasattr(store, 'jyacs_log'):
        store.jyacs_log("用户消息处理: '{}' -> '{}'".format(message, processed_message), "DEBUG")
    
    return processed_message
Screen 定义
1. jyacs_setting_pane
功能：JYACS 设置面板（集成到子模组设置中）。


screen jyacs_setting_pane():
    python:
        import store.jyacs as jyacs
        stat = _("未连接") if not jyacs.jyacs.wss_session else _("已连接") if jyacs.jyacs.is_connected() else _("已断开")
        
        # 安全地获取API密钥
        if hasattr(store, 'getAPIKey'):
            store.jyacs.jyacs.ciphertext = store.getAPIKey("Jyacs_Token")
    
    vbox:
        xmaximum 800
        xfill True
        style_prefix "check"
        
        # 状态更新定时器
        timer persistent.jyacs_setting_dict.get('status_update_time', 1.0) repeat True action Function(scr_nullfunc, _update_screens=True)
        
        # 版本检查警告
        if safe_version_check():
            text _("> 你当前的版本过旧, 可能影响正常运行, 请升级至最新版本")
        
        # 通信状态显示
        text _("> JYACS通信状态: [jyacs.jyacs.status]|[jyacs.jyacs.JyacsAiStatus.get_description(jyacs.jyacs.status)]")
        text renpy.substitute(_("> Websocket:")) + renpy.substitute(stat)
        
        # 连接按钮
        if not jyacs.jyacs.is_connected():
            textbutton _("> 使用已保存令牌连接"):
                action Call("submod_jyacs_chat_start")
        
## jyacs_expressions.rpy 技术文档
文件概述
文件名: jyacs_expressions.rpy
版本: 1.0.1
作者: Panghu1102
许可证: Apache License 2.0
用途: JYACS 表情系统，基于 JUSTYURI 的表情编码系统实现，负责解析表情编码、显示角色表情和情绪分析。

目录
表情编码系统
核心类：yuri_display
表情解析函数
情绪分析
辅助函数
使用示例
表情编码速查表
表情编码系统
JUSTYURI 表情编码格式
格式：X-YYYYY-ZZZZ

X: 头部位置 (1 字符)
   A = 正面 (front)
   B = 侧面 (side)

YYYYY: 面部特征 (5 字符)
   Y1 = 眼睛 (Base64 索引: A-Z, a-z, 0-9, +, /)
   Y2 = 嘴巴 (小写字母: a-z)
   Y3 = 眉毛 (小写字母: a-z)
   Y4 = 脸红 (A=无, B=有)
   Y5 = 哭泣 (A=无, B=有)

ZZZZ: 手臂位置 (4 字符)
   双臂模式: AAZZ[index]
   单臂模式: AA[left][right]
示例：

| 编码 | 含义 | |------|------| | A-ACAAA-AAAA | 正面、中性眼睛、a嘴、a眉、无脸红、无哭泣、默认手臂 | | A-CFGAA-AIAI | 正面、开心眼睛、f嘴、g眉、无脸红、无哭泣、特定手臂姿势 | | B-BFAAA-AAAC | 侧面、思考眼睛、f嘴、a眉、无脸红、无哭泣、手臂姿势C |

核心类：yuri_display
类结构
init -1200 python:
    class yuri_display:
        """
        优里表情显示系统，基于JUSTYURI的实现
        处理表情编码并显示对应的表情
        """
        
        values = {
            "position": "sit",      # 姿势：sit/stand
            "head": "front",        # 头部：front/down/side
            "eyes": 0,              # 眼睛索引
            "mouth": "a",           # 嘴巴类型
            "eyebrows": "a",        # 眉毛类型
            "blush": False,         # 是否脸红
            "cry": False,           # 是否哭泣
            "both arms": 0,         # 双臂姿势
            "left arm": 0,          # 左臂姿势
            "right arm": 0          # 右臂姿势
        }
静态方法列表
| 方法 | 参数 | 功能 | |------|------|------| | position(index) | 0=坐, 1=站 | 设置角色姿势 | | head(index) | 0=正面, 1=低头, 2=侧面 | 设置头部方向 | | eyes(index) | 0-13+ | 设置眼睛表情 | | mouth(index) | a-z | 设置嘴巴表情 | | eyebrows(index) | a-z | 设置眉毛表情 | | blush(value) | True/False | 设置脸红效果 | | cry(value) | True/False | 设置哭泣效果 | | both_arms(index) | 0-63 | 设置双臂姿势 | | left_arm(index) | 0-63 | 设置左臂姿势 | | right_arm(index) | 0-63 | 设置右臂姿势 | | show() | 无 | 显示当前表情 |

表情解析函数
base64_to_index()
功能：将 Base64 字符转换为索引（0-63）。

def base64_to_index(char):
    """将Base64字符转换为索引"""
    base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    try:
        return base64_chars.index(char)
    except ValueError:
        return 0
show_chr()
功能：解析并显示表情编码。

参数：

expression (str): 表情编码 (X-YYYYY-ZZZZ)
chr (str): 角色名称（默认 "yuri_sit"）
position (list): 位置列表（默认 ["t11"]）
解析流程：

def show_chr(expression, chr="yuri_sit", position=["t11"]):
    # 1. 格式验证和修正
    if expression == "default":
        expression = "A-ACAAA-AAAA"
    
    if expression.count('-') == 1:
        expression = 'A-' + expression
    
    if list(map(lambda x: len(x), expression.split('-'))) != [1, 5, 4]:
        expression = "A-AAAAA-AAAA"
    
    # 2. 解析头部 (索引 0)
    head = "front" if expression[0] == "A" else "side"
    yuri_display.head(0 if head == "front" else 1)
    
    # 3. 解析眼睛 (索引 2)
    eyes_index = base64_to_index(expression[2])
    yuri_display.eyes(eyes_index)
    
    # 4. 解析嘴巴 (索引 3)
    mouth = expression[3].lower()
    yuri_display.mouth(mouth)
    
    # 5. 解析眉毛 (索引 4)
    eyebrows = expression[4].lower()
    yuri_display.eyebrows(eyebrows)
    
    # 6. 解析脸红 (索引 5)
    blush = (expression[5] == "B")
    yuri_display.blush(blush)
    
    # 7. 解析哭泣 (索引 6)
    cry = (expression[6] == "B")
    yuri_display.cry(cry)
    
    # 8. 解析手臂 (索引 8-11)
    if expression[8:10] == "ZZ":
        # 双臂模式
        both_arms_index = base64_to_index(expression[10])
        yuri_display.both_arms(both_arms_index)
    else:
        # 单臂模式
        left_arm_index = base64_to_index(expression[9])
        right_arm_index = base64_to_index(expression[11])
        yuri_display.left_arm(left_arm_index)
        yuri_display.right_arm(right_arm_index)
    
    # 9. 显示表情
    yuri_display.show()
    
    return expression
情绪分析
get_emotion_from_expression()
功能：根据当前表情状态返回情绪名称。

def get_emotion_from_expression():
    """根据当前表情状态返回对应的情绪名称"""
    eyes = yuri_display.values["eyes"]
    mouth = yuri_display.values["mouth"]
    eyebrows = yuri_display.values["eyebrows"]
    blush = yuri_display.values["blush"]
    cry = yuri_display.values["cry"]
    
    # 情绪判断逻辑
    if eyes in [0, 1] and mouth == "a" and eyebrows == "a":
        return "normal"
    elif eyes in [2, 3] and mouth == "a" and eyebrows == "b":
        return "think_and_interested"
    elif eyes in [7, 8, 9] and mouth in ["c", "f"] and eyebrows == "a":
        return "happy"
    elif eyes in [4, 5, 6] and mouth in ["g", "f"] and eyebrows == "a":
        return "relaxing_and_happy"
    elif eyes in [10, 11] and mouth == "b" and eyebrows == "a" and blush:
        return "kind"
    elif eyes in [2, 3] and mouth in ["b", "c"] and eyebrows in ["a", "e"] and not blush:
        return "think_and_a_little_worry"
    elif eyes in [4, 5] and mouth in ["a", "b"] and eyebrows in ["a", "l"] and not cry:
        return "a_little_sad"
    elif eyes in [6, 7, 8] and mouth in ["a", "b"] and eyebrows in ["a", "b"] and cry:
        return "sad"
    elif eyes in [9, 10] and mouth in ["c", "b"] and eyebrows == "b" and blush:
        return "unhappy"
    elif eyes in [0, 1] and mouth == "a" and eyebrows in ["a", "b"]:
        return "relaxed"
    else:
        return "normal"
情绪类型：

| 情绪名称 | 说明 | |---------|------| | normal | 中性/平静 | | happy | 开心/高兴 | | kind | 温柔/友善 | | sad | 悲伤 | | think_and_interested | 思考/感兴趣 | | think_and_a_little_worry | 思考且略微担忧 | | relaxing_and_happy | 放松且开心 | | a_little_sad | 轻微悲伤 | | unhappy | 不开心/生气 | | relaxed | 放松 |

get_expression_from_text()
功能：从文本分析关键词并返回对应的表情编码。

参数：

text (str): 要分析的文本
返回值：

str: JUSTYURI 表情编码
关键词映射表：

keyword_to_expression = {
    # 积极情绪 - 开心
    '开心': "A-CFGAA-AIAI",
    '高兴': "A-CFGAA-AIAI", 
    '快乐': "A-CFGAA-AIAI",
    
    # 积极情绪 - 兴奋
    '愉快': "A-GCBAA-AEAB",
    '兴奋': "A-GCBAA-AEAB",
    '幸福': "A-GCBAA-AEAB",
    
    # 积极情绪 - 喜欢
    '喜欢': "A-CABBA-ALAL",
    '可爱': "A-CABBA-ALAL",
    
    # 温柔情绪
    '爱': "A-CABBA-AMAM",
    '温柔': "A-CABBA-AMAM",
    '亲切': "A-CABBA-AMAM",
    
    # 中性/思考
    '思考': "A-BFAAA-AAAC",
    '想': "A-BFAAA-AAAC",
    '考虑': "A-BFAAA-AAAC",
    
    # 担心/忧虑
    '担心': "A-AFBAA-ALAA",
    '忧虑': "A-AFBAA-ALAA",
    
    # 轻微消极
    '有点': "A-HECAA-AEAB",
    '稍微': "A-HECAA-AEAB",
    
    # 悲伤情绪
    '难过': "A-DGFAA-ABAB",
    '伤心': "A-DGFAA-ABAB",
    '悲伤': "A-DGFAA-ABAB",
    
    # 害怕/恐惧
    '害怕': "A-KFCAA-ABAB",
    '恐惧': "A-KFCAA-ABAB",
    
    # 生气
    '生气': "A-HCBBA-ABAB",
    '愤怒': "A-HCBBA-ABAB",
    
    # 惊讶
    '惊讶': "A-ICAAA-ALAL",
    '震惊': "A-ICAAA-ALAL",
    
    # 平静
    '平静': "A-ACAAA-AAAA",
    '安心': "A-ACAAA-AAAA",
}
实现逻辑：

def get_expression_from_text(text):
    # 1. 输入验证
    if not text or not isinstance(text, (str, unicode)):
        return "A-ACAAA-AAAA"
    
    # 2. 限制长度
    if len(text) > 10000:
        text = text[:10000]
    
    # 3. 扫描关键词
    try:
        for keyword, expression in keyword_to_expression.items():
            if keyword in text:
                return expression
    except Exception as e:
        print(u"[JYACS] 表情分析出错: {}".format(e))
    
    # 4. 返回默认表情
    return "A-ACAAA-AAAA"
辅助函数
jyacs_show_emotion_from_text()
功能：一站式函数，从文本分析、显示表情到返回情绪名称。

def jyacs_show_emotion_from_text(text):
    """从文本分析并显示表情的便捷函数"""
    expression = get_expression_from_text(text)
    show_chr(expression)
    return get_emotion_from_expression()
使用流程：

输入: "我很开心！"
    ↓
get_expression_from_text()
    ↓
"A-CFGAA-AIAI"
    ↓
show_chr()
    ↓
显示开心表情
    ↓
get_emotion_from_expression()
    ↓
返回: "happy"
使用示例
1. 基本使用
# 显示默认表情
show_chr("A-ACAAA-AAAA")

# 显示开心表情
show_chr("A-CFGAA-AIAI")

# 显示悲伤表情
show_chr("A-DGFAA-ABAB")
2. 链式调用
# 手动构建表情
yuri_display.head(0).eyes(2).mouth("f").eyebrows("a").blush(False).show()
3. 从文本分析
# AI 回复
ai_reply = "我很开心见到你！"

# 分析并显示
expression = get_expression_from_text(ai_reply)
show_chr(expression)

# 获取情绪
emotion = get_emotion_from_expression()
print(emotion)  # 输出: "happy"
4. 完整对话流程
# 在 jyacs_main.rpy 中的使用
message = store.jyacs.get_message()
if message:
    expression_code, text = message
    
    # 显示表情
    show_chr(expression_code)
    
    # 显示对话
    y(text)
表情编码速查表
常用表情编码
| 情绪 | 编码 | 说明 | |------|------|------| | 中性 | A-ACAAA-AAAA | 默认表情 | | 开心 | A-CFGAA-AIAI | 开心笑容 | | 兴奋 | A-GCBAA-AEAB | 兴奋激动 | | 喜欢 | A-CABBA-ALAL | 喜欢可爱 | | 温柔 | A-CABBA-AMAM | 温柔关怀 | | 思考 | A-BFAAA-AAAC | 思考状态 | | 担心 | A-AFBAA-ALAA | 担心忧虑 | | 轻微消极 | A-HECAA-AEAB | 有点不安 | | 悲伤 | A-DGFAA-ABAB | 悲伤难过 | | 害怕 | A-KFCAA-ABAB | 害怕恐惧 | | 生气 | A-HCBBA-ABAB | 生气愤怒 | | 惊讶 | A-ICAAA-ALAL | 惊讶震惊 |

编码组成部分
头部位置：

A = 正面
B = 侧面
眼睛索引（Base64）：

A (0) = 正常
B (1) = 正常变体
C (2) = 思考
D (3) = 思考变体
G (6) = 放松
H (7) = 开心
I (8) = 开心变体
K (10) = 温柔
嘴巴类型：

a = 闭嘴/中性
b = 微笑
c = 开心笑
f = 说话
g = 大笑
眉毛类型：

a = 正常
b = 皱眉/担忧
e = 惊讶
l = 悲伤
脸红/哭泣：

A = 无
B = 有
注意事项
编码格式验证：

必须是 X-YYYYY-ZZZZ 格式
如果格式错误，会自动修正为默认表情
关键词优先级：

按照字典顺序扫描
第一个匹配的关键词决定表情
建议文本中只包含一个主要情绪关键词
性能考虑：

文本长度限制为 10000 字符
关键词扫描是线性的，复杂度 O(n*m)
兼容性：

支持 Python 2.7 的 unicode 类型
异常安全，失败时返回默认表情
扩展性：

可以通过修改 keyword_to_expression 添加新关键词
可以通过修改 get_emotion_from_expression() 添加新情绪类型
版本历史
1.0.1: 当前版本
完整的 JUSTYURI 表情编码支持
关键词到表情的自动映射
情绪分析功能
链式调用支持
文档版本: 1.0
维护者: Panghu1102        

## jyacs_framework.rpy 技术文档
文件概述
文件名: jyacs_framework.rpy
版本: 1.0.1
作者: Panghu1102
许可证: Apache License 2.0
用途: JYACS 基础框架支持，提供子模组系统、控制台系统和 UI 系统的基础类和兼容性函数。

目录
初始化层级
核心类
全局实例
兼容性函数
样式定义
Screen 定义
初始化层级
init -1500: 基础框架类定义
init -1500 python:
    import logging
优先级说明：

使用 -1500 优先级确保在大多数模块之前加载
在 jyacs_init.rpy (-1700) 之后
在 jyacs_api.rpy (-1400) 之前
提供基础类供其他模块使用
核心类
1. SubmodUtils
功能：子模组工具类，用于管理和注册子模组。

class SubmodUtils:
    """子模组工具类"""
    
    def __init__(self):
        self.submod_log = logging.getLogger("JYACS_Submod")
        self.submod_log.setLevel(logging.INFO)
方法列表
Submod()
功能：注册子模组。

def Submod(self, *args, **kwargs):
    """子模组注册"""
    if not hasattr(store, "registered_submods"):
        store.registered_submods = []
    store.registered_submods.append(kwargs)
参数（通过 kwargs）：

author (str): 作者名称
name (str): 子模组名称
description (str): 描述
version (str): 版本号
settings_pane (str): 设置面板 screen 名称
使用示例：

store.jyacs_submod_utils.Submod(
    author="Panghu1102",
    name="JustYuriAIChatSubmod",
    description="基于API的AI聊天系统",
    version="1.0.1",
    settings_pane="jyacs_setting_pane"
)
isSubmodInstalled()
功能：检查子模组是否已安装。

def isSubmodInstalled(self, name):
    """检查子模组是否已安装"""
    return False
参数：

name (str): 子模组名称
返回值：

bool: 是否已安装（当前实现始终返回 False）
注意：这是一个占位实现，实际功能未完全实现。

getAndRunFunctions()
功能：获取并运行注册的函数。

def getAndRunFunctions(self):
    """获取并运行函数"""
    pass
注意：这是一个占位实现，实际功能未完全实现。

functionplugin()
功能：函数插件装饰器。

def functionplugin(self, *args, **kwargs):
    """函数插件装饰器"""
    def wrapper(f):
        return f
    return wrapper
使用示例：

@store.jyacs_submod_utils.functionplugin()
def my_custom_function():
    pass
注意：当前实现不做任何修改，直接返回原函数。

2. ConsoleSystem
功能：控制台系统类，管理控制台显示和历史记录。

class ConsoleSystem:
    """控制台系统"""
    
    def __init__(self):
        self.console_history = []
        self.font = "mod_assets/font/SarasaMonoTC-SemiBold.ttf"
属性：

| 属性 | 类型 | 默认值 | 说明 | |------|------|--------|------| | console_history | list | [] | 控制台历史记录 | | font | str | "mod_assets/font/..." | 控制台字体路径 |

用途：

存储控制台输出历史
管理控制台字体设置
提供控制台相关的配置
3. UISystem
功能：UI 系统类，管理 UI 相关的配置。

class UISystem:
    """UI系统"""
    
    def __init__(self):
        self.MONO_FONT = "mod_assets/font/SarasaMonoTC-SemiBold.ttf"
属性：

| 属性 | 类型 | 默认值 | 说明 | |------|------|--------|------| | MONO_FONT | str | "mod_assets/font/..." | 等宽字体路径 |

用途：

提供统一的字体配置
管理 UI 相关的全局设置
全局实例
init -1400: 创建全局实例
init -1400 python:
    # 创建全局实例（带安全检查）
    if not hasattr(store, 'jyacs_submod_utils'):
        store.jyacs_submod_utils = SubmodUtils()
    
    if not hasattr(store, 'jyacs_console'):
        store.jyacs_console = ConsoleSystem()
    
    if not hasattr(store, 'jyacs_ui'):
        store.jyacs_ui = UISystem()
安全检查：

使用 hasattr() 检查实例是否已存在
避免重复创建实例
支持热重载和模块重新加载
全局实例列表：

| 实例名 | 类型 | 用途 | |--------|------|------| | store.jyacs_submod_utils | SubmodUtils | 子模组管理 | | store.jyacs_console | ConsoleSystem | 控制台管理 | | store.jyacs_ui | UISystem | UI 配置管理 |

兼容性函数
功能占位函数
为了确保与其他模块的兼容性，提供了一些占位函数：

# 兼容性函数
def getAPIKey(key_name):
    """获取API密钥"""
    return ""

def random_ask():
    """随机提问"""
    return False

def rev_unseen():
    """获取未读消息"""
    return []

def mobile_min_timescamp():
    """获取移动端最小时间戳"""
    return 0
注册到 store：

# 注册到store（带安全检查）
if not hasattr(store, 'getAPIKey'):
    store.getAPIKey = getAPIKey

if not hasattr(store, 'random_ask'):
    store.random_ask = random_ask

if not hasattr(store, 'rev_unseen'):
    store.rev_unseen = rev_unseen

if not hasattr(store, 'mobile_min_timescamp'):
    store.mobile_min_timescamp = mobile_min_timescamp
函数说明：

| 函数名 | 参数 | 返回值 | 说明 | |--------|------|--------|------| | getAPIKey(key_name) | str | str | 获取 API 密钥（占位） | | random_ask() | 无 | bool | 随机提问功能（占位） | | rev_unseen() | 无 | list | 获取未读消息（占位） | | mobile_min_timescamp() | 无 | int | 移动端时间戳（占位） |

注意：这些函数是占位实现，实际功能可能在其他模块中实现或覆盖。

样式定义
控制台样式
style jyacs_console_frame:
    background "#000000CC"
    padding (20, 20)
    xalign 0.5
    yalign 0.5
    xsize 800
    ysize 600
样式属性：

| 属性 | 值 | 说明 | |------|-----|------| | background | #000000CC | 半透明黑色背景 | | padding | (20, 20) | 内边距 | | xalign | 0.5 | 水平居中 | | yalign | 0.5 | 垂直居中 | | xsize | 800 | 宽度 | | ysize | 600 | 高度 |

控制台按钮样式
style jyacs_console_button is button:
    background "#7C4A4A"
    hover_background "#8C5A5A"
    padding (15, 8)

style jyacs_console_button_text is button_text:
    size 16
    color "#FFFFFF"
按钮样式：

| 样式 | 属性 | 值 | 说明 | |------|------|-----|------| | jyacs_console_button | background | #7C4A4A | 按钮背景色（深红） | | | hover_background | #8C5A5A | 悬停背景色（浅红） | | | padding | (15, 8) | 内边距 | | jyacs_console_button_text | size | 16 | 字体大小 | | | color | #FFFFFF | 文字颜色（白色） |

Screen 定义
jyacs_console
功能：JYACS 控制台界面。

screen jyacs_console():
    tag menu
    modal True
    
    frame:
        style "jyacs_console_frame"
        
        vbox:
            spacing 10
            
            # 标题
            text "JYACS Console" size 24 color "#FFFFFF"
            
            # 控制台输出区域
            viewport:
                mousewheel True
                scrollbars "vertical"
                
                vbox:
                    if hasattr(store, 'jyacs_console') and hasattr(store.jyacs_console, 'console_history'):
                        for line in store.jyacs_console.console_history[-20:]:
                            text line color "#CCCCCC"
            
            # 按钮区域
            hbox:
                spacing 20
                xalign 0.5
                
                textbutton "关闭" action Hide("jyacs_console") style "jyacs_console_button"
界面结构：

┌─────────────────────────────────┐
│      JYACS Console              │
├─────────────────────────────────┤
│                                 │
│  控制台输出（最近20条）          │
│  - 日志行1                       │
│  - 日志行2                       │
│  - ...                          │
│                                 │
├─────────────────────────────────┤
│          [关闭]                  │
└─────────────────────────────────┘
特性：

| 特性 | 说明 | |------|------| | tag menu | 作为菜单界面 | | modal True | 模态窗口，阻止其他交互 | | 滚动条 | 支持鼠标滚轮和滚动条 | | 历史限制 | 只显示最近 20 条记录 | | 安全检查 | 检查 console_history 是否存在 |

使用方法：

# 显示控制台
renpy.show_screen("jyacs_console")

# 隐藏控制台
renpy.hide_screen("jyacs_console")

# 添加日志到控制台
store.jyacs_console.console_history.append("这是一条日志")
使用示例
1. 注册子模组
# 在 header.rpy 或其他初始化文件中
store.jyacs_submod_utils.Submod(
    author="Panghu1102",
    name="JustYuriAIChatSubmod",
    description="基于API的AI聊天系统",
    version="1.0.1",
    settings_pane="jyacs_setting_pane"
)
2. 使用控制台
# 添加日志
store.jyacs_console.console_history.append("[INFO] 系统启动")
store.jyacs_console.console_history.append("[DEBUG] 加载配置文件")

# 显示控制台
renpy.show_screen("jyacs_console")

# 修改字体
store.jyacs_console.font = "mod_assets/font/CustomFont.ttf"
3. 使用 UI 配置
# 获取等宽字体
mono_font = store.jyacs_ui.MONO_FONT

# 在 screen 中使用
screen my_custom_screen():
    text "等宽文本" font store.jyacs_ui.MONO_FONT
4. 检查子模组
# 检查是否安装了某个子模组
if store.jyacs_submod_utils.isSubmodInstalled("Better Loading"):
    print("Better Loading 已安装")
架构设计
模块依赖关系
jyacs_framework.rpy (基础框架)
    ↓ 提供基础类
jyacs_init.rpy (初始化)
    ↓ 使用框架类
jyacs_api.rpy (API 核心)
    ↓ 使用日志系统
其他模块
类关系图
SubmodUtils
    ├─ submod_log (logging.Logger)
    ├─ Submod()
    ├─ isSubmodInstalled()
    ├─ getAndRunFunctions()
    └─ functionplugin()

ConsoleSystem
    ├─ console_history (list)
    └─ font (str)

UISystem
    └─ MONO_FONT (str)
设计模式
1. 单例模式
# 全局实例，确保只创建一次
if not hasattr(store, 'jyacs_submod_utils'):
    store.jyacs_submod_utils = SubmodUtils()
优点：

全局唯一实例
避免重复创建
便于访问和管理
2. 装饰器模式
@store.jyacs_submod_utils.functionplugin()
def my_function():
    pass
用途：

扩展函数功能
注册插件函数
实现钩子系统
3. 占位符模式
def getAPIKey(key_name):
    """获取API密钥"""
    return ""
用途：

提供接口定义
避免未定义错误
支持后续实现
注意事项
初始化顺序：

框架类必须在其他模块之前初始化
使用合适的 init 优先级
安全检查：

所有全局实例创建都使用 hasattr() 检查
避免覆盖已存在的实例
占位实现：

部分函数是占位实现
实际功能可能在其他模块中实现
日志系统：

使用 Python 标准 logging 模块
日志级别可配置
字体路径：

确保字体文件存在于指定路径
路径相对于游戏根目录
扩展指南
添加新的框架类
class MyCustomSystem:
    """自定义系统类"""
    
    def __init__(self):
        self.config = {}
    
    def my_method(self):
        pass

# 创建全局实例
if not hasattr(store, 'my_custom_system'):
    store.my_custom_system = MyCustomSystem()
扩展 SubmodUtils
class ExtendedSubmodUtils(SubmodUtils):
    """扩展的子模组工具类"""
    
    def __init__(self):
        super(ExtendedSubmodUtils, self).__init__()
        self.custom_feature = True
    
    def new_method(self):
        """新功能"""
        pass
版本历史
1.0.1: 当前版本
基础框架类实现
控制台系统
UI 系统
兼容性函数
文档版本: 1.0
维护者: Panghu1102  

## jyacs_init.rpy 技术文档
文件概述
文件名: jyacs_init.rpy
版本: 1.0.1
作者: Panghu1102
许可证: Apache License 2.0
用途: JYACS 初始化文件，负责路径设置、持久化数据初始化、兼容性函数定义和晚期初始化钩子。

目录
初始化层级
路径设置
持久化数据初始化
兼容性函数
晚期初始化
钩子系统
初始化层级
优先级结构
init -1700: 路径设置
    ↓
init -1650: 持久化数据初始化
    ↓
init -1600: 兼容性函数定义
    ↓
init 1500: 钩子系统注册
设计原则：

使用极高优先级（-1700）确保最早执行
分层初始化，避免依赖冲突
提供降级处理机制
路径设置
init -1700: Python 包路径配置
init -1700 python:
    import sys
    import os
    import traceback
    
    # 1. 路径设置（更稳健的方式）
    python_packages_path = os.path.join(config.gamedir, "python-packages")
    if not os.path.isdir(python_packages_path):
        python_packages_path = os.path.join(config.basedir, "python-packages")
    
    if os.path.isdir(python_packages_path):
        if python_packages_path not in sys.path:
            sys.path.insert(0, python_packages_path)
            print(u"JYACS: 已添加python-packages路径: {}".format(python_packages_path))
    else:
        # 如果路径不存在，尝试创建
        try:
            os.makedirs(python_packages_path, exist_ok=True)
            if python_packages_path not in sys.path:
                sys.path.insert(0, python_packages_path)
            print(u"JYACS: 'python-packages' 目录已创建于: {}".format(python_packages_path))
        except Exception as e:
            print(u"JYACS: 创建 'python-packages' 目录失败: {}".format(e))
路径查找顺序：

1. config.gamedir/python-packages
   ↓ (如果不存在)
2. config.basedir/python-packages
   ↓ (如果不存在)
3. 尝试创建目录
关键特性：

| 特性 | 说明 | |------|------| | 双路径检查 | 先检查 gamedir，再检查 basedir | | 自动创建 | 如果目录不存在，尝试自动创建 | | 重复检查 | 使用 not in sys.path 避免重复添加 | | 优先插入 | 使用 insert(0, ...) 确保优先级 | | 异常安全 | 创建失败不会中断初始化 |

路径变量：

| 变量 | 类型 | 说明 | |------|------|------| | config.gamedir | str | 游戏目录（通常是 game/） | | config.basedir | str | 基础目录（项目根目录） | | python_packages_path | str | 最终确定的包路径 |

持久化数据初始化
init -1650: 基础持久化数据设置
init -1650 python:
    # 2. 基础持久化数据设置
    # 使用 hasattr 检查，避免重复定义
    
    if not hasattr(persistent, 'jyacs_setting_dict'):
        persistent.jyacs_setting_dict = {
            "api_key": "", 
            "api_url": "", 
            "model_name": "jyacs_main",
            "auto_connect": True, 
            "auto_reconnect": True, 
            "enable_triggers": True,
            "enable_emotion": True, 
            "show_console_when_reply": False,
            "target_lang": "zh_cn", 
            "use_custom_model_config": False,
            "strict_mode": False,
            "log_level": "INFO", 
            "log_conlevel": "INFO"
        }
持久化数据结构：

1. jyacs_setting_dict
功能：主设置字典。

| 键 | 类型 | 默认值 | 说明 | |-----|------|--------|------| | api_key | str | "" | API 密钥 | | api_url | str | "" | API 端点地址 | | model_name | str | "jyacs_main" | 模型名称 | | auto_connect | bool | True | 自动连接 | | auto_reconnect | bool | True | 自动重连 | | enable_triggers | bool | True | 启用触发器 | | enable_emotion | bool | True | 启用情绪分析 | | show_console_when_reply | bool | False | 回复时显示控制台 | | target_lang | str | "zh_cn" | 目标语言 | | use_custom_model_config | bool | False | 使用自定义模型配置 | | strict_mode | bool | False | 严格模式 | | log_level | str | "INFO" | 日志级别 | | log_conlevel | str | "INFO" | 控制台日志级别 |

2. jyacs_advanced_setting
功能：高级设置字典。

if not hasattr(persistent, 'jyacs_advanced_setting'):
    persistent.jyacs_advanced_setting = {
        "temperature": 0.7, 
        "top_p": 0.9, 
        "max_tokens": 2048,
        "frequency_penalty": 0.0, 
        "presence_penalty": 0.0,
        "mf_aggressive": False, 
        "sfe_aggressive": False, 
        "esc_aggressive": True,
        "nsfw_acceptive": True, 
        "seed": 0, 
        "_seed": "0"
    }
| 键 | 类型 | 默认值 | 说明 | |-----|------|--------|------| | temperature | float | 0.7 | 模型温度 | | top_p | float | 0.9 | 核采样参数 | | max_tokens | int | 2048 | 最大 token 数 | | frequency_penalty | float | 0.0 | 频率惩罚 | | presence_penalty | float | 0.0 | 存在惩罚 | | mf_aggressive | bool | False | MFocus 激进模式 | | sfe_aggressive | bool | False | SFE 激进模式 | | esc_aggressive | bool | True | ESC 激进模式 | | nsfw_acceptive | bool | True | NSFW 接受度 | | seed | int | 0 | 随机种子 | | _seed | str | "0" | 种子字符串表示 |

3. jyacs_advanced_setting_status
功能：高级设置启用状态。

if not hasattr(persistent, 'jyacs_advanced_setting_status'):
    persistent.jyacs_advanced_setting_status = {}
用途：控制哪些高级设置被应用。

4. jyacs_log_history
功能：日志历史记录。

if not hasattr(persistent, 'jyacs_log_history'):
    persistent.jyacs_log_history = []
5. 其他持久化数据
if not hasattr(persistent, '_jyacs_send_or_received_mpostals'):
    persistent._jyacs_send_or_received_mpostals = []

# 确保玩家信息存在
if not hasattr(persistent, 'jyacs_player_additions'):
    persistent.jyacs_player_additions = []
数据说明：

| 变量 | 类型 | 用途 | |------|------|------| | _jyacs_send_or_received_mpostals | list | 邮件记录（已废弃） | | jyacs_player_additions | list | 玩家补充信息 |

兼容性函数
init -1600: 兼容性函数定义
1. jyacs_progress_bar()
功能：进度条显示函数。

if not hasattr(store, 'jyacs_progress_bar'):
    def jyacs_progress_bar(percentage, current=None, total=None, bar_length=20):
        """进度条显示函数"""
        filled_length = int(round(bar_length * percentage / 100.0))
        bar = u'▇' * filled_length + u' ' * (bar_length - filled_length)
        
        if total is not None:
            return u'|{}| {}% | {} / {}'.format(bar, int(percentage), current, total)
        else:
            return u'|{}| {}%'.format(bar, int(percentage))
    
    store.jyacs_progress_bar = jyacs_progress_bar
参数：

| 参数 | 类型 | 必需 | 说明 | |------|------|------|------| | percentage | float | 是 | 百分比（0-100） | | current | int | 否 | 当前值 | | total | int | 否 | 总值 | | bar_length | int | 否 | 进度条长度（默认 20） |

返回值示例：

# 只有百分比
jyacs_progress_bar(50)
# 输出: "|▇▇▇▇▇▇▇▇▇▇          | 50%"

# 带当前值和总值
jyacs_progress_bar(75, 75, 100)
# 输出: "|▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇     | 75% | 75 / 100"
2. jyacs_basic_log()
功能：基本日志记录函数。

if not hasattr(store, 'jyacs_basic_log'):
    def jyacs_basic_log(message, level="INFO"):
        """基本日志记录函数"""
        try:
            print(u"[JYACS-{}] {}".format(level, message))
        except:
            print("[JYACS-{}] <encoding error>".format(level))
    
    store.jyacs_basic_log = jyacs_basic_log
参数：

| 参数 | 类型 | 默认值 | 说明 | |------|------|--------|------| | message | str | - | 日志消息 | | level | str | "INFO" | 日志级别 |

特性：

异常安全：编码错误时显示占位符
Unicode 兼容
简单可靠
晚期初始化
jyacs_late_init()
功能：执行依赖于其他模块的初始化。

def jyacs_late_init():
    """执行依赖于其他模块的初始化"""
    try:
        # 初始化情绪分析器
        try:
            from jyacs_emotion import JyacsEmotionAnalyzer
            store.emotion_analyzer = JyacsEmotionAnalyzer()
            print("JYACS: 情绪分析器已初始化")
            if hasattr(store, 'jyacs_logger') and store.jyacs_logger:
                store.jyacs_logger.log_info("情绪分析器已初始化")
        except ImportError as e:
            print("JYACS: 无法导入情绪分析模块: {}".format(e))
            store.emotion_analyzer = None
        
        # 设置日志级别
        if hasattr(store, 'jyacs_logger') and store.jyacs_logger:
            log_level_str = persistent.jyacs_setting_dict.get("log_level", "INFO").upper()
            log_level = getattr(logging, log_level_str, logging.INFO)
            store.jyacs_logger.logger.setLevel(log_level)
            store.jyacs_logger.log_info("JYACS 初始化完成")
        else:
            print("JYACS: Logger尚未初始化，跳过日志级别设置。")
    except Exception as e:
        print(u"JYACS 晚期初始化失败: {}".format(e))
        traceback.print_exc()
初始化步骤：

1. 导入情绪分析模块
   ↓
2. 创建情绪分析器实例
   ↓
3. 设置日志级别
   ↓
4. 记录初始化完成
错误处理：

模块导入失败：设置 emotion_analyzer = None
日志系统未就绪：跳过日志级别设置
任何异常：打印错误信息和堆栈跟踪
钩子系统
label jyacs_after_load
功能：自定义加载后标签。

label jyacs_after_load:
    python:
        jyacs_late_init()
    return
用途：

在游戏加载后执行晚期初始化
不覆盖原游戏的 after_load 标签
init 1500: 加载钩子注册
init 1500 python:
    # 安全地添加after_load钩子
    def jyacs_after_load_hook():
        """JYACS加载后钩子"""
        jyacs_late_init()
        return
    
    # 如果原始after_load存在，不要覆盖它
    if renpy.has_label("after_load"):
        print("JYACS: 检测到原始after_load标签，添加钩子")
        # 这里可以添加钩子代码，但我们使用更安全的方式
    else:
        print("JYACS: 未检测到原始after_load标签，创建新标签")
        
        # 定义一个安全的after_load标签
        @renpy.register_label("after_load")
        def _jyacs_after_load_label():
            jyacs_late_init()
            return
钩子策略：

| 情况 | 处理方式 | |------|---------| | after_load 存在 | 添加钩子，不覆盖 | | after_load 不存在 | 注册新标签 |

安全机制：

使用 renpy.has_label() 检查标签是否存在
使用 @renpy.register_label() 动态注册
避免覆盖原游戏的重要标签
初始化流程图
游戏启动
    ↓
init -1700: 路径设置
    ├─ 查找 python-packages 目录
    ├─ 添加到 sys.path
    └─ 创建目录（如果不存在）
    ↓
init -1650: 持久化数据初始化
    ├─ jyacs_setting_dict
    ├─ jyacs_advanced_setting
    ├─ jyacs_advanced_setting_status
    ├─ jyacs_log_history
    └─ jyacs_player_additions
    ↓
init -1600: 兼容性函数定义
    ├─ jyacs_progress_bar
    └─ jyacs_basic_log
    ↓
其他模块初始化
    ↓
init 1500: 钩子系统注册
    └─ after_load 钩子
    ↓
游戏加载完成
    ↓
after_load 触发
    ↓
jyacs_late_init()
    ├─ 初始化情绪分析器
    └─ 设置日志级别
    ↓
JYACS 完全就绪
使用示例
1. 访问持久化数据
# 读取设置
api_key = persistent.jyacs_setting_dict.get("api_key", "")
auto_connect = persistent.jyacs_setting_dict.get("auto_connect", True)

# 修改设置
persistent.jyacs_setting_dict["api_key"] = "new_key"
persistent.jyacs_setting_dict["auto_connect"] = False
2. 使用进度条
# 简单进度条
progress = store.jyacs_progress_bar(50)
print(progress)  # |▇▇▇▇▇▇▇▇▇▇          | 50%

# 带详细信息的进度条
progress = store.jyacs_progress_bar(75, 75, 100)
print(progress)  # |▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇     | 75% | 75 / 100
3. 使用基本日志
# 记录日志
store.jyacs_basic_log("系统启动", "INFO")
store.jyacs_basic_log("配置加载失败", "ERROR")
store.jyacs_basic_log("调试信息", "DEBUG")
4. 手动触发晚期初始化
# 在需要时手动调用
jyacs_late_init()
设计原则
1. 分层初始化
基础设施层 (-1700)
    ↓
数据层 (-1650)
    ↓
工具层 (-1600)
    ↓
应用层 (其他模块)
    ↓
钩子层 (1500)
优点：

清晰的依赖关系
避免循环依赖
易于调试和维护
2. 安全检查
if not hasattr(persistent, 'jyacs_setting_dict'):
    # 初始化
优点：

避免重复初始化
支持热重载
保护已有数据
3. 降级处理
try:
    # 尝试导入模块
except ImportError:
    # 使用占位符
优点：

模块缺失不会导致崩溃
提供基本功能
便于调试
4. 异常安全
try:
    # 操作
except Exception as e:
    print("错误: {}".format(e))
    traceback.print_exc()
优点：

错误不会中断初始化
提供详细的错误信息
便于问题定位
注意事项
初始化顺序：

必须在所有其他 JYACS 模块之前执行
使用极高优先级（-1700）
路径设置：

确保 python-packages 目录存在
检查路径是否正确添加到 sys.path
持久化数据：

使用 hasattr() 避免覆盖已有数据
提供合理的默认值
兼容性函数：

提供基本功能的占位实现
可被其他模块覆盖
钩子系统：

不要覆盖原游戏的重要标签
使用安全的注册方式
晚期初始化：

依赖于其他模块的初始化放在这里
提供完善的错误处理
故障排除
问题 1: python-packages 路径未添加
症状：无法导入 jyacs_emotion 等模块

解决方案：

# 检查路径
print(sys.path)

# 手动添加
sys.path.insert(0, "path/to/python-packages")
问题 2: 持久化数据丢失
症状：设置被重置为默认值

解决方案：

# 检查是否存在
print(hasattr(persistent, 'jyacs_setting_dict'))

# 手动恢复
persistent.jyacs_setting_dict = {...}
问题 3: 晚期初始化失败
症状：情绪分析器未初始化

解决方案：

# 手动调用
jyacs_late_init()

# 检查错误
import traceback
traceback.print_exc()
版本历史
1.0.1: 当前版本
路径设置系统
持久化数据初始化
兼容性函数
晚期初始化钩子
文档版本: 1.0
维护者: Panghu1102

## jyacs_main.rpy 技术文档
文件概述
文件名: jyacs_main.rpy
版本: 1.0.1
作者: Panghu1102
许可证: Apache License 2.0
用途: JYACS 主要游戏脚本，包含对话系统、标签定义、样式设置和核心游戏逻辑。

重要说明：

移除了强制背景设置，使用原游戏的 jy_bg 动态背景系统
原游戏会根据 persistent.bg、bg_list 和 current_timecycle_marker 自动显示正确的背景
目录
样式定义
初始化变量
核心标签
对话循环
状态管理
Screen 定义
样式定义
init 50: 样式定义
init 50 python:
    # 确保不覆盖已有样式
    style.jyacs_input_text = Style(style.text)
    style.jyacs_input_text.font = "mod_assets/font/SarasaMonoTC-SemiBold.ttf"
    style.jyacs_input_text.size = 16
    style.jyacs_input_text.color = "#FFFFFF"
    style.jyacs_input_text.outlines = [(1, "#000000", 0, 0)]
样式属性：

| 属性 | 值 | 说明 | |------|-----|------| | font | "mod_assets/font/..." | 字体路径 | | size | 16 | 字体大小 | | color | #FFFFFF | 文字颜色（白色） | | outlines | [(1, "#000000", 0, 0)] | 黑色描边 |

优先级说明：

使用 init 50 较低优先级
避免覆盖原游戏样式
继承自 style.text
初始化变量
init -890: 变量和函数初始化
init -890 python:
    # 创建空的消息列表
    if not hasattr(store, 'jyacs_messages'):
        store.jyacs_messages = []
    
    # 创建空的日志历史
    if not hasattr(store, 'jyacs_log_history'):
        store.jyacs_log_history = []
全局变量：

| 变量名 | 类型 | 用途 | |--------|------|------| | jyacs_messages | list | 消息列表 | | jyacs_log_history | list | 日志历史 |

辅助函数
jyacs_send_message()
功能：发送消息到 JYACS。

def jyacs_send_message(message):
    """发送消息到JYACS"""
    if not message or not message.strip():
        return
    
    # 添加到消息列表
    store.jyacs_messages.append(message)
    
    # 如果JYACS可用，发送消息
    if hasattr(store, 'jyacs') and hasattr(store.jyacs, 'chat'):
        store.jyacs.chat(message)
jyacs_progress_bar()
功能：进度条显示函数（如果不存在）。

if not hasattr(store, 'jyacs_progress_bar'):
    def jyacs_progress_bar(percentage, current=None, total=None, bar_length=20):
        """进度条显示函数"""
        filled_length = int(round(bar_length * percentage / 100.0))
        bar = '▇' * filled_length + ' ' * (bar_length - filled_length)
        
        if total is not None:
            return '|{}| {}% | {} / {}'.format(bar, int(percentage), current, total)
        elif current is not None:
            return '|{}| {}% | {}'.format(bar, int(percentage), current)
        else:
            return '|{}| {}%'.format(bar, int(percentage))
    
    store.jyacs_progress_bar = jyacs_progress_bar
init 5: 表情显示函数
show_expression()
功能：显示优里的表情。

def show_expression(emote):
    """显示优里的表情"""
    # 使用JUSTYURI表情系统
    if emote.startswith("1"):
        # 将DDLC风格的表情代码转换为JUSTYURI表情编码
        ddlc_to_justyuri = {
            "1eua": "A-ACAAA-AAAA",  # 正常/平静
            "1esa": "A-ADCAA-AAAA",  # 悲伤
            "1eub": "A-BCAAA-AAAA",  # 开心
            "1euc": "A-ACBAA-AAAA",  # 思考/感兴趣
            "1esd": "A-ADBAA-AAAA",  # 思考/担忧
            "1hub": "A-BCAAA-AAAA",  # 开心/愉快
            "1sua": "A-ACAAA-AAAA",  # 轻微惊讶
            "1lua": "A-ADAAA-AAAA",  # 轻微悲伤
            "1lsb": "A-ADCAA-AAAA",  # 悲伤/失落
            "1eka": "A-BCAAA-AAAA",  # 温柔/善良
            "1ekd": "A-ADCAA-AAAA",  # 不开心/生气
        }
        
        # 获取对应的JUSTYURI表情编码
        expression = ddlc_to_justyuri.get(emote, "A-ACAAA-AAAA")
        
        # 使用show_chr函数显示表情
        show_chr(expression)
    else:
        # 直接使用JUSTYURI表情编码
        show_chr(emote)
DDLC 到 JUSTYURI 映射表：

| DDLC 代码 | JUSTYURI 编码 | 说明 | |-----------|---------------|------| | 1eua | A-ACAAA-AAAA | 正常/平静 | | 1esa | A-ADCAA-AAAA | 悲伤 | | 1eub | A-BCAAA-AAAA | 开心 | | 1euc | A-ACBAA-AAAA | 思考/感兴趣 | | 1esd | A-ADBAA-AAAA | 思考/担忧 | | 1hub | A-BCAAA-AAAA | 开心/愉快 | | 1sua | A-ACAAA-AAAA | 轻微惊讶 | | 1lua | A-ADAAA-AAAA | 轻微悲伤 | | 1lsb | A-ADCAA-AAAA | 悲伤/失落 | | 1eka | A-BCAAA-AAAA | 温柔/善良 | | 1ekd | A-ADCAA-AAAA | 不开心/生气 |

核心标签
label submod_jyacs_chat_start
功能：启动 JYACS 对话会话。

label submod_jyacs_chat_start:
    # 设置JYACS对话状态为True
    $ jyacs_in_chat = True
    
    # 隐藏主屏幕按钮（参考JY原版实现）
    python:
        if hasattr(store, 'DisableTalk'):
            DisableTalk()
        
        # 禁用boopable（参考俄罗斯方块的实现）
        boopable = False
    
    # 不强制设置背景，使用原游戏的jy_bg动态背景系统
    
    python:
        # 重置退出请求标志
        store.jyacs_exit_requested = False
        
        # 确保应用最新的JYACS设置
        if hasattr(store, 'jyacs_apply_setting'):
            store.jyacs_apply_setting()
    
    # 使用JUSTYURI表情系统显示默认表情
    $ show_chr("A-ACAAA-AAAA")
    y "啊，要聊些话题吗....稍等一下"
    y "我准备好啦！。"
    
    jump submod_jyacs_talking
执行流程：

1. 设置对话状态标志
   ↓
2. 禁用主屏幕按钮
   ↓
3. 禁用 boopable
   ↓
4. 重置退出标志
   ↓
5. 应用最新设置
   ↓
6. 显示默认表情
   ↓
7. 显示欢迎对话
   ↓
8. 跳转到对话循环
状态变更：

| 变量 | 变更前 | 变更后 | |------|--------|--------| | jyacs_in_chat | False | True | | boopable | True | False | | jyacs_exit_requested | - | False |

label submod_jyacs_chat_end
功能：结束 JYACS 对话会话。

label submod_jyacs_chat_end:
    # 重置JYACS对话状态
    $ jyacs_in_chat = False
    
    # 恢复主屏幕按钮（参考JY原版实现）
    python:
        if hasattr(store, 'EnableTalk'):
            EnableTalk()
        
        # 恢复boopable状态
        boopable = True
        
        # 确保yuri_sit变量正确设置（使用默认表情）
        show_chr("A-ACAAA-AAAA")
    
    y "就这样吧，有什么欢迎随时找我。"
    
    # 返回主循环（参考俄罗斯方块的实现）
    jump ch30_loop
执行流程：

1. 重置对话状态
   ↓
2. 恢复主屏幕按钮
   ↓
3. 恢复 boopable
   ↓
4. 显示默认表情
   ↓
5. 显示告别对话
   ↓
6. 返回主循环
label jyacs_exit_chat
功能：退出 JYACS 对话（用户主动退出）。

label jyacs_exit_chat:
    # 重置JYACS对话状态
    $ jyacs_in_chat = False
    
    # 隐藏状态overlay
    hide screen jyacs_status_overlay
    
    # 恢复主屏幕按钮和默认状态
    python:
        if hasattr(store, 'EnableTalk'):
            EnableTalk()
        
        boopable = True
        show_chr("A-ACAAA-AAAA")
    
    # 返回主循环
    jump ch30_loop
对话循环
label submod_jyacs_talking
功能：主对话循环，处理用户输入和 AI 响应。

完整流程：

label submod_jyacs_talking:
    show yuri at t11
    show screen jyacs_status_overlay
    
    # 初始化连接
    call submod_jyacs_init_connect(use_pause_instand_wait=True)
    if _return == "disconnected":
        hide screen jyacs_status_overlay
        return "disconnected"
    
    python:
        import time
        import copy
        from jyacs_utils import JyacsLogger
        from jyacs_emotion import JyacsEmoSelector
        import traceback
        
        # 设置日志记录器
        store.jyacs.content_func = store.jyacs_log
        store.action = {}
        
        # 循环控制变量
        outer_loop_count = 0
        max_outer_loops = 100
        
        while True:
            outer_loop_count += 1
            
            # 防止无限循环
            if outer_loop_count > max_outer_loops:
                store.jyacs_log("达到最大循环次数，强制退出", "ERROR")
                _return = "max_loops"
                break
            
            # 诊断日志
            store.jyacs_log("="*60, "DEBUG")
            store.jyacs_log("外层循环 #{} 开始".format(outer_loop_count), "DEBUG")
            store.jyacs_log("is_ready_to_input: {}".format(store.jyacs.is_ready_to_input), "DEBUG")
            # ... 更多状态日志
            
            # 显示当前表情
            renpy.show("yuri {}".format(store.jyacs.MoodStatus.get_emote()))
            
            # 检查用户是否点击了"退出"按钮
            if store.jyacs_exit_requested:
                store.jyacs_log("用户点击退出按钮，结束对话", "INFO")
                store.jyacs_exit_requested = False
                _return = "user_exit"
                break
            
            # 如果准备好接收输入
            if store.jyacs.is_ready_to_input:
                # 状态验证
                validation_attempts = 0
                max_validation_attempts = 3
                
                while validation_attempts < max_validation_attempts:
                    validation_attempts += 1
                    
                    is_valid = True
                    
                    if store.jyacs.is_responding:
                        store.jyacs_log("验证失败：is_responding 应为 False", "WARNING")
                        is_valid = False
                    
                    if store.jyacs.is_chatting:
                        store.jyacs_log("验证失败：is_chatting 应为 False", "WARNING")
                        is_valid = False
                    
                    if len(store.jyacs.message_queue) > 0:
                        store.jyacs_log("验证失败：message_queue 应为空", "WARNING")
                        is_valid = False
                    
                    if is_valid:
                        break
                    else:
                        # 尝试修复
                        store.jyacs.is_responding = False
                        store.jyacs.is_chatting = False
                        store.jyacs.message_queue = []
                        renpy.pause(0.2, hard=True)
                
                # 获取用户输入
                store.jyacs_log("刷新交互状态...", "DEBUG")
                renpy.restart_interaction()
                
                question = renpy.input(
                    _("[persistent.playername]，说吧。"),
                    default="",
                    length=75 if not config.language == "english" else 375
                ).strip(' \t\n\r')
                
                if question == "":
                    continue
                if question == "nevermind":
                    _return = "canceled"
                    break
                
                # 添加到历史记录
                to_history = copy.deepcopy(_history_list[-1])
                to_history.who = persistent.playername
                to_history.what = question
                _history_list.append(to_history)
                
                # 发送消息
                store.jyacs.chat(question)
            
            # 处理响应
            inner_loop_count = 0
            max_inner_loops = 50
            
            while True:
                inner_loop_count += 1
                
                if inner_loop_count > max_inner_loops:
                    store.jyacs_log("内层循环达到最大迭代次数", "ERROR")
                    break
                
                # 检查是否有消息需要处理
                if store.jyacs.len_message_queue > 0:
                    message = store.jyacs.get_message()
                    if message:
                        expression_code, text = message
                        
                        # 显示表情
                        try:
                            show_chr(expression_code)
                        except Exception as e:
                            store.jyacs_log("显示表情失败，使用默认表情", "WARNING")
                            show_chr("A-ACAAA-AAAA")
                        
                        # 显示对话
                        y(text)
                    
                    # 检查是否完成
                    if not store.jyacs.is_responding and store.jyacs.len_message_queue == 0:
                        break
                else:
                    # 等待消息
                    if store.jyacs.is_responding:
                        y(".{w=0.3}.{w=0.3}.{w=0.3}{nw}")
                        if len(_history_list):
                            _history_list.pop()
                    renpy.pause(0.5, hard=True)
                    
                    if not store.jyacs.is_responding and store.jyacs.len_message_queue == 0:
                        break
            
            # 状态重置
            store.jyacs.is_responding = False
            store.jyacs.is_chatting = False
            
            if len(store.jyacs.message_queue) > 0:
                store.jyacs.message_queue = []
            
            renpy.pause(0.3, hard=True)
双层循环结构：

外层循环（用户输入）
    ├─ 循环计数器保护
    ├─ 状态诊断日志
    ├─ 退出检查
    ├─ 状态验证
    ├─ 获取用户输入
    ├─ 发送到 API
    └─ 内层循环（AI 响应）
        ├─ 循环计数器保护
        ├─ 获取消息
        ├─ 显示表情
        ├─ 显示对话
        └─ 等待完成
label submod_jyacs_talking.end
功能：对话结束处理。

label submod_jyacs_talking.end:
    python:
        # 清空对话历史
        if hasattr(store.jyacs, 'clear_conversation_history'):
            cleared_count = store.jyacs.clear_conversation_history()
            store.jyacs_log("对话会话结束，已清空 {} 条历史消息".format(cleared_count), "INFO")
        
        # 重置对话状态
        store.jyacs_is_chatting = False
        store.jyacs_log("对话状态已重置", "DEBUG")
    
    if persistent.jyacs_setting_dict['console']:
        $ store.jyacs_log("清理控制台...", "INFO")
        hide screen jyacs_console_teaching
        show yuri at t11
    
    hide screen jyacs_status_overlay
    return _return
状态管理
状态变量
| 变量名 | 类型 | 用途 | |--------|------|------| | jyacs_in_chat | bool | 是否在对话中 | | jyacs_exit_requested | bool | 用户是否请求退出 | | boopable | bool | 是否可以 boop | | outer_loop_count | int | 外层循环计数 | | inner_loop_count | int | 内层循环计数 |

状态转换图
空闲状态
    ↓ (用户点击 JYACS 按钮)
submod_jyacs_chat_start
    ↓
jyacs_in_chat = True
    ↓
submod_jyacs_talking (对话循环)
    ├─ 获取输入
    ├─ 发送消息
    ├─ 接收响应
    └─ 显示对话
    ↓ (用户输入 "nevermind" 或点击退出)
submod_jyacs_talking.end
    ↓
jyacs_in_chat = False
    ↓
submod_jyacs_chat_end
    ↓
ch30_loop (主循环)
Screen 定义
init 15: jyacs_status_overlay
功能：状态覆盖层，显示 AI 思考状态。

init 15 screen jyacs_status_overlay():
    zorder 100
    
    if hasattr(store, 'jyacs') and hasattr(store.jyacs, 'is_responding') and store.jyacs.is_responding:
        frame:
            background "#000000B2"
            xalign 1.0
            yalign 0.0
            padding (10, 5)
            
            text "思考中..." style "jyacs_console_text"
显示条件：

store.jyacs 存在
store.jyacs.is_responding 为 True
界面位置：

右上角（xalign 1.0, yalign 0.0）
半透明黑色背景
显示"思考中..."文本
辅助标签
label submod_jyacs_init_connect
功能：初始化连接。

label submod_jyacs_init_connect(use_pause_instand_wait=False):
    python:
        store.jyacs.content_func = store.jyacs_log
        store.jyacs_log("\n" * 25 + "=== JYACS 初始化 ===", "INFO")
        
        if not store.jyacs.is_connected:
            store.jyacs.init_connect()
        
        while True:
            if not store.jyacs.is_connected:
                store.jyacs_log("正在初始化连接...", "INFO")
                renpy.pause(0.3, True)
                if not store.jyacs.is_failed:
                    continue
            
            if not store.jyacs.is_ready_to_input and not store.jyacs.is_failed:
                store.jyacs_log("等待登录...", "INFO")
                if use_pause_instand_wait:
                    renpy.pause(1.0)
                else:
                    y(".{w=0.3}.{w=0.3}.{w=0.3}{nw}")
                    if len(_history_list):
                        _history_list.pop()
                continue
            
            if store.jyacs.is_ready_to_input:
                store.jyacs_log("登录成功，准备开始聊天！", "INFO")
                _return = "success"
                break
            elif store.jyacs.is_failed:
                store.jyacs_log("发生错误，请检查日志文件", "ERROR")
                renpy.pause(2.0)
                _return = "disconnected"
                break
    
    call submod_show_workload
    return _return
返回值：

"success": 连接成功
"disconnected": 连接失败
label submod_show_workload
功能：显示工作负载（占位）。

label submod_show_workload:
    python:
        store.jyacs_log("JYACS 初始化完成", "INFO")
    return "normal"
使用示例
1. 启动对话
# 从游戏中调用
call submod_jyacs_chat_start
2. 发送消息
# 在对话循环中
question = renpy.input("说吧。")
store.jyacs.chat(question)
3. 显示表情
# 使用 DDLC 风格代码
show_expression("1eub")  # 开心

# 使用 JUSTYURI 编码
show_chr("A-CFGAA-AIAI")  # 开心
4. 退出对话
# 用户主动退出
$ store.jyacs_exit_requested = True

# 或跳转到退出标签
jump jyacs_exit_chat
注意事项
背景系统：

不强制设置背景
使用原游戏的 jy_bg 动态背景系统
背景会根据时间和设置自动变化
状态管理：

正确设置 jyacs_in_chat 标志
恢复 boopable 状态
清理对话历史
循环保护：

外层循环最多 100 次
内层循环最多 50 次
防止无限循环导致卡死
状态验证：

输入前验证状态
最多尝试 3 次修复
失败时强制退出
异常处理：

表情显示失败使用默认表情
日志记录所有关键操作
提供详细的调试信息
版本历史
1.0.1: 当前版本
完整的对话循环系统
JUSTYURI 表情集成
状态管理和验证
循环保护机制
详细的调试日志
文档版本: 1.0
维护者: Panghu1102  

## jyacs_stub.rpy 技术文档    
文件概述
文件名: jyacs_stub.rpy
版本: 1.0.1
作者: Panghu1102
许可证: Apache License 2.0
用途: JYACS 依赖兼容层，为 Just Yuri (JY) 提供必要的占位符和兼容性函数，确保 JYACS 可以在不同环境下运行。

重要说明：

此文件是为了兼容 Just Yuri (JY) 而编写
如果要为 Just Natsuki (JN) 或其他 DDLC mod 开发，需要相应调整
提供了大量占位符实现，避免缺少依赖导致的错误
目录
初始化层级
通用辅助函数
JY 兼容层
游戏标题设置
扩展兼容性
标签检查
初始化层级
init -1500: 基础类型和辅助函数
init -1500 python:
    # 使用更低的优先级以确保不会干扰主游戏初始化
    import types
    import logging
    import store
优先级说明：

使用 -1500 确保在大多数 JYACS 模块之前加载
但在 jyacs_init.rpy (-1700) 之后
提供基础设施供其他模块使用
Python 2.7 兼容性
SimpleNamespace 实现
# Python 2.7 compatible SimpleNamespace
try:
    from types import SimpleNamespace
except ImportError:
    class SimpleNamespace(object):
        def __init__(self, **kwargs):
            self.__dict__.update(kwargs)
        
        def __repr__(self):
            keys = sorted(self.__dict__)
            items = ("{}={!r}".format(k, self.__dict__[k]) for k in keys)
            return "{}({})".format(type(self).__name__, ", ".join(items))
        
        def __eq__(self, other):
            return self.__dict__ == other.__dict__
功能：

提供类似 Python 3.3+ 的 SimpleNamespace 类
用于创建简单的命名空间对象
支持动态属性访问
使用示例：

# 创建命名空间
ns = SimpleNamespace(x=1, y=2)

# 访问属性
print(ns.x)  # 1
print(ns.y)  # 2

# 修改属性
ns.x = 10

# 添加新属性
ns.z = 3
通用辅助函数
占位符函数
# ------------------------------------------------------------------
# Generic no-op helpers
# ------------------------------------------------------------------
def _noop(*_args, **_kwargs):
    """A do-nothing placeholder function."""
    return None

def _decorator_noop(*_dargs, **_dkwargs):
    """Return a decorator that leaves the wrapped function untouched."""
    def _wrap(fn):
        return fn
    return _wrap
功能说明：

| 函数 | 用途 | 返回值 | |------|------|--------| | _noop() | 无操作占位符 | None | | _decorator_noop() | 装饰器占位符 | 原函数 |

使用场景：

提供缺失函数的占位实现
避免 AttributeError
保持代码结构完整
JY 兼容层
init -1500: 子模组工具兼容
if not hasattr(store, "jyacs_submod_utils"):
    store.jyacs_submod_utils = SimpleNamespace()
    store.jyacs_submod_utils.Submod = _noop
    store.jyacs_submod_utils.getAndRunFunctions = _noop
    store.jyacs_submod_utils.functionplugin = _decorator_noop
    store.jyacs_submod_utils.submod_log = SimpleNamespace()
    store.jyacs_submod_utils.submod_log.level = logging.INFO
    store.jyacs_submod_utils.isSubmodInstalled = lambda name: False
提供的接口：

| 接口 | 类型 | 功能 | |------|------|------| | Submod | function | 子模组注册（占位） | | getAndRunFunctions | function | 运行函数（占位） | | functionplugin | decorator | 函数插件（占位） | | submod_log | namespace | 日志对象 | | submod_log.level | int | 日志级别 | | isSubmodInstalled | function | 检查子模组（始终返回 False） |

JY 命名空间映射
# ------------------------------------------------------------------
# 创建JY相关的命名空间
# ------------------------------------------------------------------
if not hasattr(store, "jy_submod_utils"):
    store.jy_submod_utils = store.jyacs_submod_utils
功能：

将 jyacs_submod_utils 映射到 jy_submod_utils
提供 JY 风格的接口
保持命名一致性
JY UI 对象
# 提供JY相关的UI对象
if not hasattr(store, "jy_ptod"):
    store.jy_ptod = SimpleNamespace()
    store.jy_ptod.font = "mod_assets/font/SarasaMonoTC-SemiBold.ttf"

if not hasattr(store, "jy_ui"):
    store.jy_ui = SimpleNamespace()
    store.jy_ui.MONO_FONT = "mod_assets/font/SarasaMonoTC-SemiBold.ttf"
提供的对象：

| 对象 | 属性 | 值 | 说明 | |------|------|-----|------| | jy_ptod | font | "mod_assets/font/..." | PTOD 字体 | | jy_ui | MONO_FONT | "mod_assets/font/..." | 等宽字体 |

游戏标题设置
init -1600: 标题修复
init -1600 python:
    # 确保游戏标题正确设置
    # 许多Ren'Py项目（包括Just Yuri）在options.rpy中通过config.name或gui.window_title设置显示标题。
    # 如果初始化早期的错误阻止options.rpy执行，窗口会回退到通用的"A Ren'Py Game"字符串。
    # 在这里设置一个安全的默认值，确保即使其他脚本错误发生，标题也保持正确。
    
    # 我们只在尚未定义名称时设置它，以避免在已存在时覆盖真实值。
    if not getattr(config, "name", None):
        config.name = "Just Yuri with JYACS 1.0.1"
        print("JYACS: 已设置游戏标题为 'Just Yuri'")
    
    if not getattr(config, "window_title", None):
        config.window_title = "Just Yuri"
        print("JYACS: 已设置窗口标题为 'Just Yuri'")
问题背景：

Ren'Py 在初始化早期可能遇到错误
如果 options.rpy 未执行，标题会显示为 "A Ren'Py Game"
这会给用户带来困惑
解决方案：

在高优先级（-1600）设置默认标题
只在标题未设置时才设置
避免覆盖已有的正确标题
设置的值：

| 配置项 | 值 | 说明 | |--------|-----|------| | config.name | "Just Yuri with JYACS 1.0.1" | 游戏名称 | | config.window_title | "Just Yuri" | 窗口标题 |

扩展兼容性
init -1400: 辅助函数和变量
init -1400 python:
    if not hasattr(store, "getAPIKey"):
        store.getAPIKey = lambda *_args, **_kwargs: ""
JY 辅助函数
# JY辅助函数
jy_helpers = {
    "_jy_getAffection": (lambda *_a, **_k: 0),
    "jy_getAffection": (lambda *_a, **_k: 0),
    "jy_getEV": (lambda *_a, **_k: None),
    "jy_inEVL": (lambda *_a, **_k: False),
}

# 将每个辅助函数添加到store中
for _name, _default in jy_helpers.items():
    if not hasattr(store, _name):
        setattr(store, _name, _default)
提供的函数：

| 函数名 | 返回值 | 说明 | |--------|--------|------| | getAPIKey(key_name) | "" | 获取 API 密钥（占位） | | _jy_getAffection() | 0 | 获取好感度（占位） | | jy_getAffection() | 0 | 获取好感度（占位） | | jy_getEV(name) | None | 获取事件（占位） | | jy_inEVL(name) | False | 检查事件列表（占位） |

其他变量和函数
if not hasattr(store, "jy_rev_unseen"):
    store.jy_rev_unseen = []

if not hasattr(store, "player"):
    store.player = "Player"

def getEV(name):
    """Placeholder for event access function"""
    return None

if not hasattr(store, "getEV"):
    store.getEV = getEV

if not hasattr(store, "jyacs_chat_history"):
    store.jyacs_chat_history = []

if not hasattr(store, "jyacs_log"):
    def jyacs_log(message, level="INFO"):
        """Simple logging function"""
        print("[JYACS-{}] {}".format(level, message))
    store.jyacs_log = jyacs_log
提供的变量：

| 变量名 | 类型 | 默认值 | 说明 | |--------|------|--------|------| | jy_rev_unseen | list | [] | 未读消息列表 | | player | str | "Player" | 玩家名称 | | jyacs_chat_history | list | [] | 聊天历史 | | jyacs_chr_exist | bool | False | 角色文件是否存在 | | jyacs_chr_changed | bool | False | 角色文件是否改变 | | jyacs_confont | str | "mod_assets/font/..." | 控制台字体 |

登录变量
# 确保登录变量存在
if not hasattr(store, "_jyacs_LoginAcc"):
    store._jyacs_LoginAcc = ""
if not hasattr(store, "_jyacs_LoginPw"):
    store._jyacs_LoginPw = ""
if not hasattr(store, "_jyacs_LoginEmail"):
    store._jyacs_LoginEmail = ""
用途：

提供登录相关的占位变量
避免访问未定义变量的错误
标签检查
init -1300: 标签验证
init -1300 python:
    # 确保不会覆盖原游戏的标签
    if renpy.has_label("start"):
        print("JYACS: 检测到原游戏start标签，不会覆盖")
    else:
        print("JYACS: 未检测到原游戏start标签，这可能是个问题")
    
    # 检查并报告其他关键标签
    for label in ["splashscreen", "after_load", "quit"]:
        if renpy.has_label(label):
            print(u"JYACS: 检测到原游戏{}标签".format(label))
检查的标签：

| 标签名 | 重要性 | 说明 | |--------|--------|------| | start | 🔴 关键 | 游戏入口点 | | splashscreen | 🟡 重要 | 启动画面 | | after_load | 🟡 重要 | 加载后钩子 | | quit | 🟢 一般 | 退出处理 |

目的：

验证原游戏的关键标签存在
避免覆盖重要标签
提供调试信息
使用场景
场景 1: 缺少 JY 依赖
问题：

# 代码尝试访问 JY 的函数
affection = store.jy_getAffection()
# AttributeError: 'module' object has no attribute 'jy_getAffection'
解决：

# jyacs_stub.rpy 提供占位符
store.jy_getAffection = lambda *_a, **_k: 0

# 现在代码可以正常运行
affection = store.jy_getAffection()  # 返回 0
场景 2: 游戏标题错误
问题：

窗口标题显示 "A Ren'Py Game"
用户困惑
解决：

# jyacs_stub.rpy 设置默认标题
config.name = "Just Yuri with JYACS 1.0.1"
config.window_title = "Just Yuri"
场景 3: 子模组系统缺失
问题：

# 代码尝试注册子模组
store.jyacs_submod_utils.Submod(name="MyMod")
# AttributeError: 'module' object has no attribute 'jyacs_submod_utils'
解决：

# jyacs_stub.rpy 提供占位符
store.jyacs_submod_utils = SimpleNamespace()
store.jyacs_submod_utils.Submod = _noop

# 现在代码可以正常运行（虽然不做任何事）
store.jyacs_submod_utils.Submod(name="MyMod")
适配其他 Mod
为 Just Natsuki (JN) 适配
# 修改标题
config.name = "Just Natsuki with JYACS 1.0.1"
config.window_title = "Just Natsuki"

# 添加 JN 特定的辅助函数
jn_helpers = {
    "jn_getAffection": (lambda *_a, **_k: 0),
    "jn_getEV": (lambda *_a, **_k: None),
    # ... 更多 JN 函数
}
为 Forever and Ever (FAE) 适配
# 修改标题
config.name = "Forever and Ever with JYACS 1.0.1"
config.window_title = "Forever and Ever"

# 添加 FAE 特定的辅助函数
fae_helpers = {
    "fae_getRelationship": (lambda *_a, **_k: 0),
    "fae_getEvent": (lambda *_a, **_k: None),
    # ... 更多 FAE 函数
}
设计原则
1. 非侵入性
# 只在不存在时才创建
if not hasattr(store, "function_name"):
    store.function_name = placeholder
优点：

不覆盖已有功能
允许原游戏优先
支持热重载
2. 占位符优先
# 提供简单的占位实现
def _noop(*_args, **_kwargs):
    return None
优点：

避免 AttributeError
保持代码结构
便于调试
3. 安全默认值
# 提供合理的默认值
store.player = "Player"
store.jy_getAffection = lambda: 0
优点：

避免 None 错误
提供预期行为
减少特殊处理
注意事项
优先级设置：

使用高优先级（-1500 到 -1600）
确保在其他模块之前加载
但不要太高，避免干扰核心初始化
标题设置：

只在未设置时才设置
避免覆盖正确的标题
提供调试信息
占位符实现：

提供最小功能
返回合理的默认值
记录调试信息
兼容性检查：

使用 hasattr() 检查
使用 getattr() 安全访问
提供降级处理
适配其他 Mod：

修改标题设置
添加特定的辅助函数
调整命名空间
故障排除
问题 1: 标题仍显示 "A Ren'Py Game"
原因：

options.rpy 在 jyacs_stub.rpy 之后执行
覆盖了设置的标题
解决方案：

# 提高优先级
init -1700 python:
    config.name = "Just Yuri with JYACS 1.0.1"
问题 2: 函数仍然未定义
原因：

函数名拼写错误
优先级不够高
解决方案：

# 检查函数名
print(hasattr(store, "function_name"))

# 手动添加
if not hasattr(store, "function_name"):
    store.function_name = lambda: None
问题 3: 占位符被覆盖
原因：

其他模块在更高优先级定义了同名函数
解决方案：

# 降低优先级，让其他模块优先
init -1000 python:
    if not hasattr(store, "function_name"):
        store.function_name = placeholder
版本历史
1.0.1: 当前版本
完整的 JY 兼容层
游戏标题修复
Python 2.7 兼容性
标签验证系统
文档版本: 1.0
维护者: Panghu1102
适用范围: Just Yuri (JY) 及其衍生 Mod

